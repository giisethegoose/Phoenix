["e22f0f60d5b6334a89f81ec81bcc7e4fe5ed2bb4","b48f61d17b2f9b387a7afeaf2a3dcba125bcf91a",["./crypt","./json"],[100,133],{"version":3,"sources":["/home/giise/candidtwo/node_modules/@firebase/util/dist/cjs/src/jwt.js"],"names":["Object","defineProperty","exports","value","crypt_1","require","json_1","decode","token","header","claims","data","signature","parts","split","jsonEval","base64Decode","e","isValidTimestamp","now","Math","floor","Date","getTime","validSince","validUntil","hasOwnProperty","issuedAtTime","isValidFormat","decoded","isAdmin"],"mappings":"AAAA;;AAgBAA,OAAOC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C,EAAEC,OAAO,IAAT,EAA7C;AACA,IAAIC,UAAUC,QAAQ,SAAR,CAAd;AACA,IAAIC,SAASD,QAAQ,QAAR,CAAb;;AAWAH,QAAQK,MAAR,GAAiB,UAAUC,KAAV,EAAiB;AAC9B,QAAIC,SAAS,EAAb;AAAA,QAAiBC,SAAS,EAA1B;AAAA,QAA8BC,OAAO,EAArC;AAAA,QAAyCC,YAAY,EAArD;AACA,QAAI;AACA,YAAIC,QAAQL,MAAMM,KAAN,CAAY,GAAZ,CAAZ;AACAL,iBAASH,OAAOS,QAAP,CAAgBX,QAAQY,YAAR,CAAqBH,MAAM,CAAN,CAArB,KAAkC,EAAlD,CAAT;AACAH,iBAASJ,OAAOS,QAAP,CAAgBX,QAAQY,YAAR,CAAqBH,MAAM,CAAN,CAArB,KAAkC,EAAlD,CAAT;AACAD,oBAAYC,MAAM,CAAN,CAAZ;AACAF,eAAOD,OAAO,GAAP,KAAe,EAAtB;AACA,eAAOA,OAAO,GAAP,CAAP;AACH,KAPD,CAQA,OAAOO,CAAP,EAAU,CAAG;AACb,WAAO;AACHR,gBAAQA,MADL;AAEHC,gBAAQA,MAFL;AAGHC,cAAMA,IAHH;AAIHC,mBAAWA;AAJR,KAAP;AAMH,CAjBD;;AA6BAV,QAAQgB,gBAAR,GAA2B,UAAUV,KAAV,EAAiB;AACxC,QAAIE,SAASR,QAAQK,MAAR,CAAeC,KAAf,EAAsBE,MAAnC;AAAA,QAA2CS,MAAMC,KAAKC,KAAL,CAAW,IAAIC,IAAJ,GAAWC,OAAX,KAAuB,IAAlC,CAAjD;AAAA,QAA0FC,UAA1F;AAAA,QAAsGC,UAAtG;AACA,QAAI,OAAOf,MAAP,KAAkB,QAAtB,EAAgC;AAC5B,YAAIA,OAAOgB,cAAP,CAAsB,KAAtB,CAAJ,EAAkC;AAC9BF,yBAAad,OAAO,KAAP,CAAb;AACH,SAFD,MAGK,IAAIA,OAAOgB,cAAP,CAAsB,KAAtB,CAAJ,EAAkC;AACnCF,yBAAad,OAAO,KAAP,CAAb;AACH;AACD,YAAIA,OAAOgB,cAAP,CAAsB,KAAtB,CAAJ,EAAkC;AAC9BD,yBAAaf,OAAO,KAAP,CAAb;AACH,SAFD,MAGK;AAEDe,yBAAaD,aAAa,KAA1B;AACH;AACJ;AACD,WAAQL,OAAOK,UAAP,IAAqBC,UAArB,IAAmCN,OAAOK,UAA1C,IAAwDL,OAAOM,UAAvE;AACH,CAlBD;;AA6BAvB,QAAQyB,YAAR,GAAuB,UAAUnB,KAAV,EAAiB;AACpC,QAAIE,SAASR,QAAQK,MAAR,CAAeC,KAAf,EAAsBE,MAAnC;AACA,QAAI,OAAOA,MAAP,KAAkB,QAAlB,IAA8BA,OAAOgB,cAAP,CAAsB,KAAtB,CAAlC,EAAgE;AAC5D,eAAOhB,OAAO,KAAP,CAAP;AACH;AACD,WAAO,IAAP;AACH,CAND;;AAkBAR,QAAQ0B,aAAR,GAAwB,UAAUpB,KAAV,EAAiB;AACrC,QAAIqB,UAAU3B,QAAQK,MAAR,CAAeC,KAAf,CAAd;AAAA,QAAqCE,SAASmB,QAAQnB,MAAtD;AACA,WAAQ,CAAC,CAACmB,QAAQjB,SAAV,IACJ,CAAC,CAACF,MADE,IAEJ,OAAOA,MAAP,KAAkB,QAFd,IAGJA,OAAOgB,cAAP,CAAsB,KAAtB,CAHJ;AAIH,CAND;;AAiBAxB,QAAQ4B,OAAR,GAAkB,UAAUtB,KAAV,EAAiB;AAC/B,QAAIE,SAASR,QAAQK,MAAR,CAAeC,KAAf,EAAsBE,MAAnC;AACA,WAAO,OAAOA,MAAP,KAAkB,QAAlB,IAA8BA,OAAO,OAAP,MAAoB,IAAzD;AACH,CAHD","sourcesContent":["\"use strict\";\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar crypt_1 = require(\"./crypt\");\nvar json_1 = require(\"./json\");\n/**\n * Decodes a Firebase auth. token into constituent parts.\n *\n * Notes:\n * - May return with invalid / incomplete claims if there's no native base64 decoding support.\n * - Doesn't check if the token is actually valid.\n *\n * @param {?string} token\n * @return {{header: *, claims: *, data: *, signature: string}}\n */\nexports.decode = function (token) {\n    var header = {}, claims = {}, data = {}, signature = '';\n    try {\n        var parts = token.split('.');\n        header = json_1.jsonEval(crypt_1.base64Decode(parts[0]) || '');\n        claims = json_1.jsonEval(crypt_1.base64Decode(parts[1]) || '');\n        signature = parts[2];\n        data = claims['d'] || {};\n        delete claims['d'];\n    }\n    catch (e) { }\n    return {\n        header: header,\n        claims: claims,\n        data: data,\n        signature: signature\n    };\n};\n/**\n * Decodes a Firebase auth. token and checks the validity of its time-based claims. Will return true if the\n * token is within the time window authorized by the 'nbf' (not-before) and 'iat' (issued-at) claims.\n *\n * Notes:\n * - May return a false negative if there's no native base64 decoding support.\n * - Doesn't check if the token is actually valid.\n *\n * @param {?string} token\n * @return {boolean}\n */\nexports.isValidTimestamp = function (token) {\n    var claims = exports.decode(token).claims, now = Math.floor(new Date().getTime() / 1000), validSince, validUntil;\n    if (typeof claims === 'object') {\n        if (claims.hasOwnProperty('nbf')) {\n            validSince = claims['nbf'];\n        }\n        else if (claims.hasOwnProperty('iat')) {\n            validSince = claims['iat'];\n        }\n        if (claims.hasOwnProperty('exp')) {\n            validUntil = claims['exp'];\n        }\n        else {\n            // token will expire after 24h by default\n            validUntil = validSince + 86400;\n        }\n    }\n    return (now && validSince && validUntil && now >= validSince && now <= validUntil);\n};\n/**\n * Decodes a Firebase auth. token and returns its issued at time if valid, null otherwise.\n *\n * Notes:\n * - May return null if there's no native base64 decoding support.\n * - Doesn't check if the token is actually valid.\n *\n * @param {?string} token\n * @return {?number}\n */\nexports.issuedAtTime = function (token) {\n    var claims = exports.decode(token).claims;\n    if (typeof claims === 'object' && claims.hasOwnProperty('iat')) {\n        return claims['iat'];\n    }\n    return null;\n};\n/**\n * Decodes a Firebase auth. token and checks the validity of its format. Expects a valid issued-at time and non-empty\n * signature.\n *\n * Notes:\n * - May return a false negative if there's no native base64 decoding support.\n * - Doesn't check if the token is actually valid.\n *\n * @param {?string} token\n * @return {boolean}\n */\nexports.isValidFormat = function (token) {\n    var decoded = exports.decode(token), claims = decoded.claims;\n    return (!!decoded.signature &&\n        !!claims &&\n        typeof claims === 'object' &&\n        claims.hasOwnProperty('iat'));\n};\n/**\n * Attempts to peer into an auth token and determine if it's an admin auth token by looking at the claims portion.\n *\n * Notes:\n * - May return a false negative if there's no native base64 decoding support.\n * - Doesn't check if the token is actually valid.\n *\n * @param {?string} token\n * @return {boolean}\n */\nexports.isAdmin = function (token) {\n    var claims = exports.decode(token).claims;\n    return typeof claims === 'object' && claims['admin'] === true;\n};\n\n//# sourceMappingURL=jwt.js.map\n"]}]