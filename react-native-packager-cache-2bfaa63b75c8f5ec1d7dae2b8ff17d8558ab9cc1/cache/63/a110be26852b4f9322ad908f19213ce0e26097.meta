["730f0f73fb4f742a6ab2ab3d695e72ad5aac3022","22d7557749e26fd77542cd741c72c6f9c60aae3b",["@firebase/util","../api/Reference","../api/DataSnapshot","./util/Path","./util/Tree","./snap/indexes/PriorityIndex","./util/util","./util/ServerValues","./util/validation","./snap/nodeFromJSON","./snap/ChildrenNode","./Repo"],[99,144,194,239,276,322,376,421,472,515,563,616,661],{"version":3,"sources":["/home/giise/candidtwo/node_modules/@firebase/database/dist/cjs/src/core/Repo_transaction.js"],"names":["Object","defineProperty","exports","value","util_1","require","Reference_1","DataSnapshot_1","Path_1","Tree_1","PriorityIndex_1","util_2","ServerValues_1","validation_1","util_3","nodeFromJSON_1","ChildrenNode_1","Repo_1","TransactionStatus","Repo","MAX_TRANSACTION_RETRIES_","prototype","transactions_init_","transactionQueueTree_","Tree","startTransaction","path","transactionUpdate","onComplete","applyLocally","log_","valueCallback","watchRef","Reference","on","unwatcher","off","transaction","update","status","order","LUIDGenerator","retryCount","abortReason","currentWriteId","currentInputSnapshot","currentOutputSnapshotRaw","currentOutputSnapshotResolved","currentState","getLatestState_","newVal","val","undefined","snapshot","DataSnapshot","PRIORITY_INDEX","validateFirebaseData","RUN","queueNode","subTree","nodeQueue","getValue","push","setValue","priorityForNode","contains","safeGet","assert","isValidPriority","currentNode","serverSyncTree_","calcCompleteEventCache","ChildrenNode","EMPTY_NODE","getPriority","serverValues","generateServerValues","newNodeUnresolved","nodeFromJSON","newNode","resolveDeferredValueSnapshot","getNextWriteId_","events","applyUserOverwrite","eventQueue_","raiseEventsForChangedPath","sendReadyTransactions_","excludeSets","node","_this","pruneCompletedTransactionsBelowNode_","queue","buildTransactionQueue_","length","allRun","every","sendTransactionQueue_","hasChildren","forEachChild","childNode","setsToIgnore","map","txn","latestState","snapToSend","latestHash","hash","i","SENT","relativePath","Path","updateChild","dataToSend","pathToSend","server_","put","toString","callbacks","COMPLETED","concat","ackUserWrite","ref","bind","exceptionGuard","SENT_NEEDS_ABORT","NEEDS_ABORT","warn","rerunTransactions_","changedPath","rootMostTransactionNode","getAncestorTransactionNode_","rerunTransactionQueue_","txnsToRerun","filter","q","abortTransaction","newData","newDataNode","hasExplicitPriority","updatePriority","oldWriteId","newNodeResolved","splice","indexOf","setTimeout","Math","floor","lastInput","Error","front","transactionNode","getFront","popFront","transactionQueue","aggregateTransactionQueuesForNode_","sort","a","b","child","to","from","abortTransactions_","affectedPath","forEachAncestor","abortTransactionsOnNode_","forEachDescendant","lastSent"],"mappings":"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","sourcesContent":["\"use strict\";\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = require(\"@firebase/util\");\nvar Reference_1 = require(\"../api/Reference\");\nvar DataSnapshot_1 = require(\"../api/DataSnapshot\");\nvar Path_1 = require(\"./util/Path\");\nvar Tree_1 = require(\"./util/Tree\");\nvar PriorityIndex_1 = require(\"./snap/indexes/PriorityIndex\");\nvar util_2 = require(\"./util/util\");\nvar ServerValues_1 = require(\"./util/ServerValues\");\nvar validation_1 = require(\"./util/validation\");\nvar util_3 = require(\"@firebase/util\");\nvar nodeFromJSON_1 = require(\"./snap/nodeFromJSON\");\nvar ChildrenNode_1 = require(\"./snap/ChildrenNode\");\nvar Repo_1 = require(\"./Repo\");\n// TODO: This is pretty messy.  Ideally, a lot of this would move into FirebaseData, or a transaction-specific\n// component used by FirebaseData, but it has ties to user callbacks (transaction update and onComplete) as well\n// as the realtime connection (to send transactions to the server).  So that all needs to be decoupled first.\n// For now it's part of Repo, but in its own file.\n/**\n * @enum {number}\n */\nvar TransactionStatus;\n(function (TransactionStatus) {\n    // We've run the transaction and updated transactionResultData_ with the result, but it isn't currently sent to the\n    // server. A transaction will go from RUN -> SENT -> RUN if it comes back from the server as rejected due to\n    // mismatched hash.\n    TransactionStatus[TransactionStatus[\"RUN\"] = 0] = \"RUN\";\n    // We've run the transaction and sent it to the server and it's currently outstanding (hasn't come back as accepted\n    // or rejected yet).\n    TransactionStatus[TransactionStatus[\"SENT\"] = 1] = \"SENT\";\n    // Temporary state used to mark completed transactions (whether successful or aborted).  The transaction will be\n    // removed when we get a chance to prune completed ones.\n    TransactionStatus[TransactionStatus[\"COMPLETED\"] = 2] = \"COMPLETED\";\n    // Used when an already-sent transaction needs to be aborted (e.g. due to a conflicting set() call that was made).\n    // If it comes back as unsuccessful, we'll abort it.\n    TransactionStatus[TransactionStatus[\"SENT_NEEDS_ABORT\"] = 3] = \"SENT_NEEDS_ABORT\";\n    // Temporary state used to mark transactions that need to be aborted.\n    TransactionStatus[TransactionStatus[\"NEEDS_ABORT\"] = 4] = \"NEEDS_ABORT\";\n})(TransactionStatus = exports.TransactionStatus || (exports.TransactionStatus = {}));\n/**\n * If a transaction does not succeed after 25 retries, we abort it.  Among other things this ensure that if there's\n * ever a bug causing a mismatch between client / server hashes for some data, we won't retry indefinitely.\n * @type {number}\n * @const\n * @private\n */\nRepo_1.Repo.MAX_TRANSACTION_RETRIES_ = 25;\n/**\n * Setup the transaction data structures\n * @private\n */\nRepo_1.Repo.prototype.transactions_init_ = function () {\n    /**\n     * Stores queues of outstanding transactions for Firebase locations.\n     *\n     * @type {!Tree.<Array.<!Transaction>>}\n     * @private\n     */\n    this.transactionQueueTree_ = new Tree_1.Tree();\n};\n/**\n * Creates a new transaction, adds it to the transactions we're tracking, and sends it to the server if possible.\n *\n * @param {!Path} path Path at which to do transaction.\n * @param {function(*):*} transactionUpdate Update callback.\n * @param {?function(?Error, boolean, ?DataSnapshot)} onComplete Completion callback.\n * @param {boolean} applyLocally Whether or not to make intermediate results visible\n */\nRepo_1.Repo.prototype.startTransaction = function (path, transactionUpdate, onComplete, applyLocally) {\n    this.log_('transaction on ' + path);\n    // Add a watch to make sure we get server updates.\n    var valueCallback = function () { };\n    var watchRef = new Reference_1.Reference(this, path);\n    watchRef.on('value', valueCallback);\n    var unwatcher = function () {\n        watchRef.off('value', valueCallback);\n    };\n    // Initialize transaction.\n    var transaction = {\n        path: path,\n        update: transactionUpdate,\n        onComplete: onComplete,\n        // One of TransactionStatus enums.\n        status: null,\n        // Used when combining transactions at different locations to figure out which one goes first.\n        order: util_2.LUIDGenerator(),\n        // Whether to raise local events for this transaction.\n        applyLocally: applyLocally,\n        // Count of how many times we've retried the transaction.\n        retryCount: 0,\n        // Function to call to clean up our .on() listener.\n        unwatcher: unwatcher,\n        // Stores why a transaction was aborted.\n        abortReason: null,\n        currentWriteId: null,\n        currentInputSnapshot: null,\n        currentOutputSnapshotRaw: null,\n        currentOutputSnapshotResolved: null\n    };\n    // Run transaction initially.\n    var currentState = this.getLatestState_(path);\n    transaction.currentInputSnapshot = currentState;\n    var newVal = transaction.update(currentState.val());\n    if (newVal === undefined) {\n        // Abort transaction.\n        transaction.unwatcher();\n        transaction.currentOutputSnapshotRaw = null;\n        transaction.currentOutputSnapshotResolved = null;\n        if (transaction.onComplete) {\n            // We just set the input snapshot, so this cast should be safe\n            var snapshot = new DataSnapshot_1.DataSnapshot(transaction.currentInputSnapshot, new Reference_1.Reference(this, transaction.path), PriorityIndex_1.PRIORITY_INDEX);\n            transaction.onComplete(null, false, snapshot);\n        }\n    }\n    else {\n        validation_1.validateFirebaseData('transaction failed: Data returned ', newVal, transaction.path);\n        // Mark as run and add to our queue.\n        transaction.status = TransactionStatus.RUN;\n        var queueNode = this.transactionQueueTree_.subTree(path);\n        var nodeQueue = queueNode.getValue() || [];\n        nodeQueue.push(transaction);\n        queueNode.setValue(nodeQueue);\n        // Update visibleData and raise events\n        // Note: We intentionally raise events after updating all of our transaction state, since the user could\n        // start new transactions from the event callbacks.\n        var priorityForNode = void 0;\n        if (typeof newVal === 'object' &&\n            newVal !== null &&\n            util_3.contains(newVal, '.priority')) {\n            priorityForNode = util_3.safeGet(newVal, '.priority');\n            util_1.assert(validation_1.isValidPriority(priorityForNode), 'Invalid priority returned by transaction. ' +\n                'Priority must be a valid string, finite number, server value, or null.');\n        }\n        else {\n            var currentNode = this.serverSyncTree_.calcCompleteEventCache(path) ||\n                ChildrenNode_1.ChildrenNode.EMPTY_NODE;\n            priorityForNode = currentNode.getPriority().val();\n        }\n        priorityForNode /** @type {null|number|string} */ = priorityForNode;\n        var serverValues = this.generateServerValues();\n        var newNodeUnresolved = nodeFromJSON_1.nodeFromJSON(newVal, priorityForNode);\n        var newNode = ServerValues_1.resolveDeferredValueSnapshot(newNodeUnresolved, serverValues);\n        transaction.currentOutputSnapshotRaw = newNodeUnresolved;\n        transaction.currentOutputSnapshotResolved = newNode;\n        transaction.currentWriteId = this.getNextWriteId_();\n        var events = this.serverSyncTree_.applyUserOverwrite(path, newNode, transaction.currentWriteId, transaction.applyLocally);\n        this.eventQueue_.raiseEventsForChangedPath(path, events);\n        this.sendReadyTransactions_();\n    }\n};\n/**\n * @param {!Path} path\n * @param {Array.<number>=} excludeSets A specific set to exclude\n * @return {Node}\n * @private\n */\nRepo_1.Repo.prototype.getLatestState_ = function (path, excludeSets) {\n    return (this.serverSyncTree_.calcCompleteEventCache(path, excludeSets) ||\n        ChildrenNode_1.ChildrenNode.EMPTY_NODE);\n};\n/**\n * Sends any already-run transactions that aren't waiting for outstanding transactions to\n * complete.\n *\n * Externally it's called with no arguments, but it calls itself recursively with a particular\n * transactionQueueTree node to recurse through the tree.\n *\n * @param {Tree.<Array.<Transaction>>=} node  transactionQueueTree node to start at.\n * @private\n */\nRepo_1.Repo.prototype.sendReadyTransactions_ = function (node) {\n    var _this = this;\n    if (node === void 0) { node = this.transactionQueueTree_; }\n    // Before recursing, make sure any completed transactions are removed.\n    if (!node) {\n        this.pruneCompletedTransactionsBelowNode_(node);\n    }\n    if (node.getValue() !== null) {\n        var queue = this.buildTransactionQueue_(node);\n        util_1.assert(queue.length > 0, 'Sending zero length transaction queue');\n        var allRun = queue.every(function (transaction) { return transaction.status === TransactionStatus.RUN; });\n        // If they're all run (and not sent), we can send them.  Else, we must wait.\n        if (allRun) {\n            this.sendTransactionQueue_(node.path(), queue);\n        }\n    }\n    else if (node.hasChildren()) {\n        node.forEachChild(function (childNode) {\n            _this.sendReadyTransactions_(childNode);\n        });\n    }\n};\n/**\n * Given a list of run transactions, send them to the server and then handle the result (success or failure).\n *\n * @param {!Path} path The location of the queue.\n * @param {!Array.<Transaction>} queue Queue of transactions under the specified location.\n * @private\n */\nRepo_1.Repo.prototype.sendTransactionQueue_ = function (path, queue) {\n    var _this = this;\n    // Mark transactions as sent and increment retry count!\n    var setsToIgnore = queue.map(function (txn) {\n        return txn.currentWriteId;\n    });\n    var latestState = this.getLatestState_(path, setsToIgnore);\n    var snapToSend = latestState;\n    var latestHash = latestState.hash();\n    for (var i = 0; i < queue.length; i++) {\n        var txn = queue[i];\n        util_1.assert(txn.status === TransactionStatus.RUN, 'tryToSendTransactionQueue_: items in queue should all be run.');\n        txn.status = TransactionStatus.SENT;\n        txn.retryCount++;\n        var relativePath = Path_1.Path.relativePath(path, txn.path);\n        // If we've gotten to this point, the output snapshot must be defined.\n        snapToSend = snapToSend.updateChild(relativePath /**@type {!Node} */, txn.currentOutputSnapshotRaw);\n    }\n    var dataToSend = snapToSend.val(true);\n    var pathToSend = path;\n    // Send the put.\n    this.server_.put(pathToSend.toString(), dataToSend, function (status) {\n        _this.log_('transaction put response', {\n            path: pathToSend.toString(),\n            status: status\n        });\n        var events = [];\n        if (status === 'ok') {\n            // Queue up the callbacks and fire them after cleaning up all of our transaction state, since\n            // the callback could trigger more transactions or sets.\n            var callbacks = [];\n            for (var i = 0; i < queue.length; i++) {\n                queue[i].status = TransactionStatus.COMPLETED;\n                events = events.concat(_this.serverSyncTree_.ackUserWrite(queue[i].currentWriteId));\n                if (queue[i].onComplete) {\n                    // We never unset the output snapshot, and given that this transaction is complete, it should be set\n                    var node = queue[i].currentOutputSnapshotResolved;\n                    var ref = new Reference_1.Reference(_this, queue[i].path);\n                    var snapshot = new DataSnapshot_1.DataSnapshot(node, ref, PriorityIndex_1.PRIORITY_INDEX);\n                    callbacks.push(queue[i].onComplete.bind(null, null, true, snapshot));\n                }\n                queue[i].unwatcher();\n            }\n            // Now remove the completed transactions.\n            _this.pruneCompletedTransactionsBelowNode_(_this.transactionQueueTree_.subTree(path));\n            // There may be pending transactions that we can now send.\n            _this.sendReadyTransactions_();\n            _this.eventQueue_.raiseEventsForChangedPath(path, events);\n            // Finally, trigger onComplete callbacks.\n            for (var i = 0; i < callbacks.length; i++) {\n                util_2.exceptionGuard(callbacks[i]);\n            }\n        }\n        else {\n            // transactions are no longer sent.  Update their status appropriately.\n            if (status === 'datastale') {\n                for (var i = 0; i < queue.length; i++) {\n                    if (queue[i].status === TransactionStatus.SENT_NEEDS_ABORT)\n                        queue[i].status = TransactionStatus.NEEDS_ABORT;\n                    else\n                        queue[i].status = TransactionStatus.RUN;\n                }\n            }\n            else {\n                util_2.warn('transaction at ' + pathToSend.toString() + ' failed: ' + status);\n                for (var i = 0; i < queue.length; i++) {\n                    queue[i].status = TransactionStatus.NEEDS_ABORT;\n                    queue[i].abortReason = status;\n                }\n            }\n            _this.rerunTransactions_(path);\n        }\n    }, latestHash);\n};\n/**\n * Finds all transactions dependent on the data at changedPath and reruns them.\n *\n * Should be called any time cached data changes.\n *\n * Return the highest path that was affected by rerunning transactions.  This is the path at which events need to\n * be raised for.\n *\n * @param {!Path} changedPath The path in mergedData that changed.\n * @return {!Path} The rootmost path that was affected by rerunning transactions.\n * @private\n */\nRepo_1.Repo.prototype.rerunTransactions_ = function (changedPath) {\n    var rootMostTransactionNode = this.getAncestorTransactionNode_(changedPath);\n    var path = rootMostTransactionNode.path();\n    var queue = this.buildTransactionQueue_(rootMostTransactionNode);\n    this.rerunTransactionQueue_(queue, path);\n    return path;\n};\n/**\n * Does all the work of rerunning transactions (as well as cleans up aborted transactions and whatnot).\n *\n * @param {Array.<Transaction>} queue The queue of transactions to run.\n * @param {!Path} path The path the queue is for.\n * @private\n */\nRepo_1.Repo.prototype.rerunTransactionQueue_ = function (queue, path) {\n    if (queue.length === 0) {\n        return; // Nothing to do!\n    }\n    // Queue up the callbacks and fire them after cleaning up all of our transaction state, since\n    // the callback could trigger more transactions or sets.\n    var callbacks = [];\n    var events = [];\n    // Ignore all of the sets we're going to re-run.\n    var txnsToRerun = queue.filter(function (q) {\n        return q.status === TransactionStatus.RUN;\n    });\n    var setsToIgnore = txnsToRerun.map(function (q) {\n        return q.currentWriteId;\n    });\n    for (var i = 0; i < queue.length; i++) {\n        var transaction = queue[i];\n        var relativePath = Path_1.Path.relativePath(path, transaction.path);\n        var abortTransaction = false, abortReason = void 0;\n        util_1.assert(relativePath !== null, 'rerunTransactionsUnderNode_: relativePath should not be null.');\n        if (transaction.status === TransactionStatus.NEEDS_ABORT) {\n            abortTransaction = true;\n            abortReason = transaction.abortReason;\n            events = events.concat(this.serverSyncTree_.ackUserWrite(transaction.currentWriteId, true));\n        }\n        else if (transaction.status === TransactionStatus.RUN) {\n            if (transaction.retryCount >= Repo_1.Repo.MAX_TRANSACTION_RETRIES_) {\n                abortTransaction = true;\n                abortReason = 'maxretry';\n                events = events.concat(this.serverSyncTree_.ackUserWrite(transaction.currentWriteId, true));\n            }\n            else {\n                // This code reruns a transaction\n                var currentNode = this.getLatestState_(transaction.path, setsToIgnore);\n                transaction.currentInputSnapshot = currentNode;\n                var newData = queue[i].update(currentNode.val());\n                if (newData !== undefined) {\n                    validation_1.validateFirebaseData('transaction failed: Data returned ', newData, transaction.path);\n                    var newDataNode = nodeFromJSON_1.nodeFromJSON(newData);\n                    var hasExplicitPriority = typeof newData === 'object' &&\n                        newData != null &&\n                        util_3.contains(newData, '.priority');\n                    if (!hasExplicitPriority) {\n                        // Keep the old priority if there wasn't a priority explicitly specified.\n                        newDataNode = newDataNode.updatePriority(currentNode.getPriority());\n                    }\n                    var oldWriteId = transaction.currentWriteId;\n                    var serverValues = this.generateServerValues();\n                    var newNodeResolved = ServerValues_1.resolveDeferredValueSnapshot(newDataNode, serverValues);\n                    transaction.currentOutputSnapshotRaw = newDataNode;\n                    transaction.currentOutputSnapshotResolved = newNodeResolved;\n                    transaction.currentWriteId = this.getNextWriteId_();\n                    // Mutates setsToIgnore in place\n                    setsToIgnore.splice(setsToIgnore.indexOf(oldWriteId), 1);\n                    events = events.concat(this.serverSyncTree_.applyUserOverwrite(transaction.path, newNodeResolved, transaction.currentWriteId, transaction.applyLocally));\n                    events = events.concat(this.serverSyncTree_.ackUserWrite(oldWriteId, true));\n                }\n                else {\n                    abortTransaction = true;\n                    abortReason = 'nodata';\n                    events = events.concat(this.serverSyncTree_.ackUserWrite(transaction.currentWriteId, true));\n                }\n            }\n        }\n        this.eventQueue_.raiseEventsForChangedPath(path, events);\n        events = [];\n        if (abortTransaction) {\n            // Abort.\n            queue[i].status = TransactionStatus.COMPLETED;\n            // Removing a listener can trigger pruning which can muck with mergedData/visibleData (as it prunes data).\n            // So defer the unwatcher until we're done.\n            (function (unwatcher) {\n                setTimeout(unwatcher, Math.floor(0));\n            })(queue[i].unwatcher);\n            if (queue[i].onComplete) {\n                if (abortReason === 'nodata') {\n                    var ref = new Reference_1.Reference(this, queue[i].path);\n                    // We set this field immediately, so it's safe to cast to an actual snapshot\n                    var lastInput /** @type {!Node} */ = queue[i].currentInputSnapshot;\n                    var snapshot = new DataSnapshot_1.DataSnapshot(lastInput, ref, PriorityIndex_1.PRIORITY_INDEX);\n                    callbacks.push(queue[i].onComplete.bind(null, null, false, snapshot));\n                }\n                else {\n                    callbacks.push(queue[i].onComplete.bind(null, new Error(abortReason), false, null));\n                }\n            }\n        }\n    }\n    // Clean up completed transactions.\n    this.pruneCompletedTransactionsBelowNode_(this.transactionQueueTree_);\n    // Now fire callbacks, now that we're in a good, known state.\n    for (var i = 0; i < callbacks.length; i++) {\n        util_2.exceptionGuard(callbacks[i]);\n    }\n    // Try to send the transaction result to the server.\n    this.sendReadyTransactions_();\n};\n/**\n * Returns the rootmost ancestor node of the specified path that has a pending transaction on it, or just returns\n * the node for the given path if there are no pending transactions on any ancestor.\n *\n * @param {!Path} path The location to start at.\n * @return {!Tree.<Array.<!Transaction>>} The rootmost node with a transaction.\n * @private\n */\nRepo_1.Repo.prototype.getAncestorTransactionNode_ = function (path) {\n    var front;\n    // Start at the root and walk deeper into the tree towards path until we find a node with pending transactions.\n    var transactionNode = this.transactionQueueTree_;\n    while ((front = path.getFront()) !== null &&\n        transactionNode.getValue() === null) {\n        transactionNode = transactionNode.subTree(front);\n        path = path.popFront();\n    }\n    return transactionNode;\n};\n/**\n * Builds the queue of all transactions at or below the specified transactionNode.\n *\n * @param {!Tree.<Array.<Transaction>>} transactionNode\n * @return {Array.<Transaction>} The generated queue.\n * @private\n */\nRepo_1.Repo.prototype.buildTransactionQueue_ = function (transactionNode) {\n    // Walk any child transaction queues and aggregate them into a single queue.\n    var transactionQueue = [];\n    this.aggregateTransactionQueuesForNode_(transactionNode, transactionQueue);\n    // Sort them by the order the transactions were created.\n    transactionQueue.sort(function (a, b) {\n        return a.order - b.order;\n    });\n    return transactionQueue;\n};\n/**\n * @param {!Tree.<Array.<Transaction>>} node\n * @param {Array.<Transaction>} queue\n * @private\n */\nRepo_1.Repo.prototype.aggregateTransactionQueuesForNode_ = function (node, queue) {\n    var _this = this;\n    var nodeQueue = node.getValue();\n    if (nodeQueue !== null) {\n        for (var i = 0; i < nodeQueue.length; i++) {\n            queue.push(nodeQueue[i]);\n        }\n    }\n    node.forEachChild(function (child) {\n        _this.aggregateTransactionQueuesForNode_(child, queue);\n    });\n};\n/**\n * Remove COMPLETED transactions at or below this node in the transactionQueueTree_.\n *\n * @param {!Tree.<Array.<!Transaction>>} node\n * @private\n */\nRepo_1.Repo.prototype.pruneCompletedTransactionsBelowNode_ = function (node) {\n    var _this = this;\n    var queue = node.getValue();\n    if (queue) {\n        var to = 0;\n        for (var from = 0; from < queue.length; from++) {\n            if (queue[from].status !== TransactionStatus.COMPLETED) {\n                queue[to] = queue[from];\n                to++;\n            }\n        }\n        queue.length = to;\n        node.setValue(queue.length > 0 ? queue : null);\n    }\n    node.forEachChild(function (childNode) {\n        _this.pruneCompletedTransactionsBelowNode_(childNode);\n    });\n};\n/**\n * Aborts all transactions on ancestors or descendants of the specified path.  Called when doing a set() or update()\n * since we consider them incompatible with transactions.\n *\n * @param {!Path} path Path for which we want to abort related transactions.\n * @return {!Path}\n * @private\n */\nRepo_1.Repo.prototype.abortTransactions_ = function (path) {\n    var _this = this;\n    var affectedPath = this.getAncestorTransactionNode_(path).path();\n    var transactionNode = this.transactionQueueTree_.subTree(path);\n    transactionNode.forEachAncestor(function (node) {\n        _this.abortTransactionsOnNode_(node);\n    });\n    this.abortTransactionsOnNode_(transactionNode);\n    transactionNode.forEachDescendant(function (node) {\n        _this.abortTransactionsOnNode_(node);\n    });\n    return affectedPath;\n};\n/**\n * Abort transactions stored in this transaction queue node.\n *\n * @param {!Tree.<Array.<Transaction>>} node Node to abort transactions for.\n * @private\n */\nRepo_1.Repo.prototype.abortTransactionsOnNode_ = function (node) {\n    var queue = node.getValue();\n    if (queue !== null) {\n        // Queue up the callbacks and fire them after cleaning up all of our transaction state, since\n        // the callback could trigger more transactions or sets.\n        var callbacks = [];\n        // Go through queue.  Any already-sent transactions must be marked for abort, while the unsent ones\n        // can be immediately aborted and removed.\n        var events = [];\n        var lastSent = -1;\n        for (var i = 0; i < queue.length; i++) {\n            if (queue[i].status === TransactionStatus.SENT_NEEDS_ABORT) {\n                // Already marked.  No action needed.\n            }\n            else if (queue[i].status === TransactionStatus.SENT) {\n                util_1.assert(lastSent === i - 1, 'All SENT items should be at beginning of queue.');\n                lastSent = i;\n                // Mark transaction for abort when it comes back.\n                queue[i].status = TransactionStatus.SENT_NEEDS_ABORT;\n                queue[i].abortReason = 'set';\n            }\n            else {\n                util_1.assert(queue[i].status === TransactionStatus.RUN, 'Unexpected transaction status in abort');\n                // We can abort it immediately.\n                queue[i].unwatcher();\n                events = events.concat(this.serverSyncTree_.ackUserWrite(queue[i].currentWriteId, true));\n                if (queue[i].onComplete) {\n                    var snapshot = null;\n                    callbacks.push(queue[i].onComplete.bind(null, new Error('set'), false, snapshot));\n                }\n            }\n        }\n        if (lastSent === -1) {\n            // We're not waiting for any sent transactions.  We can clear the queue.\n            node.setValue(null);\n        }\n        else {\n            // Remove the transactions we aborted.\n            queue.length = lastSent + 1;\n        }\n        // Now fire the callbacks.\n        this.eventQueue_.raiseEventsForChangedPath(node.path(), events);\n        for (var i = 0; i < callbacks.length; i++) {\n            util_2.exceptionGuard(callbacks[i]);\n        }\n    }\n};\n\n//# sourceMappingURL=Repo_transaction.js.map\n"]}]