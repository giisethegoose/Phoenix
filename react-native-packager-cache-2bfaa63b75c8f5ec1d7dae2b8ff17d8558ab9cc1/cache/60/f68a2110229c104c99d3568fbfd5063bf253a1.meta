["2f6bf6e8b6759d41d05b5c55f2737ded2267fd3b","4447b2a3ff635b57d69d8152e3b32ae059a465b5",["../index.js","../utils/log.js","../fs","../utils/unicode","./Blob"],[116,211,305,392,497],{"version":3,"sources":["/home/giise/candidtwo/node_modules/react-native-fetch-blob/polyfill/Fetch.js"],"names":["log","disable","Fetch","config","RNFetchBlobFetchPolyfill","build","url","options","body","promise","Promise","resolve","blobCache","headers","ctype","ctypeH","method","FormData","verbose","then","b","multipartBoundary","wrap","_ref","isRNFetchBlobPolyfill","blobPath","JSON","stringify","toString","progressHandler","uploadHandler","cancelHandler","statefulPromise","task","fetch","progress","uploadProgress","cancel","resp","close","RNFetchBlobFetchRepsonse","fn","info","ok","status","type","bodyUsed","rnfbRespInfo","rnfbResp","readArrayBuffer","readText","readJSON","readBlob","rnfbEncode","readFile","buffer","str","text","i","charCodeAt","blob","json"],"mappings":"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","sourcesContent":["import RNFetchBlob from '../index.js'\nimport Log from '../utils/log.js'\nimport fs from '../fs'\nimport unicode from '../utils/unicode'\nimport Blob from './Blob'\n\nconst log = new Log('FetchPolyfill')\n\nlog.disable()\n// log.level(3)\n\nexport default class Fetch {\n\n  constructor(config:RNFetchBlobConfig) {\n    Object.assign(this, new RNFetchBlobFetchPolyfill(config))\n  }\n\n}\n\nclass RNFetchBlobFetchPolyfill {\n\n  constructor(config:RNFetchBlobConfig) {\n    this.build = () => (url, options = {}) => {\n\n      let body = options.body\n      let promise = Promise.resolve()\n      let blobCache = null\n\n      options.headers = options.headers || {}\n      let ctype = options['Content-Type'] || options['content-type']\n      let ctypeH = options.headers['Content-Type'] || options.headers['content-type']\n      options.headers['Content-Type'] = ctype || ctypeH\n      options.headers['content-type'] = ctype || ctypeH\n      options.method = options.method || 'GET'\n      if(body) {\n        // When the request body is an instance of FormData, create a Blob cache\n        // to upload the body.\n        if(body instanceof FormData) {\n          log.verbose('convert FormData to blob body')\n          promise = Blob.build(body).then((b) => {\n            blobCache = b\n            options.headers['Content-Type'] = 'multipart/form-data;boundary=' + b.multipartBoundary\n            return Promise.resolve(RNFetchBlob.wrap(b._ref))\n          })\n        }\n        // When request body is a Blob, use file URI of the Blob as request body.\n        else if (body.isRNFetchBlobPolyfill)\n          promise = Promise.resolve(RNFetchBlob.wrap(body.blobPath))\n        else if (typeof body !== 'object' && options.headers['Content-Type'] !== 'application/json')\n          promise = Promise.resolve(JSON.stringify(body))\n        else if (typeof body !== 'string')\n          promise = Promise.resolve(body.toString())\n        // send it as-is, leave the native module decide how to send the body.\n        else\n          promise = Promise.resolve(body)\n      }\n      // task is a progress reportable and cancellable Promise, however,\n      // task.then is not, so we have to extend task.then with progress and\n      // cancel function\n      let progressHandler, uploadHandler, cancelHandler\n      let statefulPromise = promise\n          .then((body) => {\n            let task = RNFetchBlob.config(config)\n              .fetch(options.method, url, options.headers, body)\n            if(progressHandler)\n              task.progress(progressHandler)\n            if(uploadHandler)\n              task.uploadProgress(uploadHandler)\n            if(cancelHandler)\n              task.cancel()\n            return task.then((resp) => {\n              log.verbose('response', resp)\n              // release blob cache created when sending request\n              if(blobCache !== null && blobCache instanceof Blob)\n                blobCache.close()\n              return Promise.resolve(new RNFetchBlobFetchRepsonse(resp))\n            })\n          })\n\n      // extend task.then progress with report and cancelling functions\n      statefulPromise.progress = (fn) => {\n        progressHandler = fn\n      }\n      statefulPromise.uploadProgress = (fn) => {\n        uploadHandler = fn\n      }\n      statefulPromise.cancel = () => {\n        cancelHandler = true\n        if(task.cancel)\n          task.cancel()\n      }\n\n      return statefulPromise\n\n    }\n  }\n\n}\n\nclass RNFetchBlobFetchRepsonse {\n\n  constructor(resp:FetchBlobResponse) {\n    let info = resp.info()\n    this.headers = info.headers\n    this.ok = info.status >= 200 && info.status <= 299,\n    this.status = info.status\n    this.type = 'basic'\n    this.bodyUsed = false\n    this.resp = resp\n    this.rnfbRespInfo = info\n    this.rnfbResp = resp\n  }\n\n  rawResp() {\n    return Promise.resolve(this.rnfbResp)\n  }\n\n  arrayBuffer(){\n    log.verbose('to arrayBuffer', this.rnfbRespInfo)\n    this.bodyUsed = true\n    return readArrayBuffer(this.rnfbResp, this.rnfbRespInfo)\n  }\n\n  text() {\n    log.verbose('to text', this.rnfbResp, this.rnfbRespInfo)\n    this.bodyUsed = true\n    return readText(this.rnfbResp, this.rnfbRespInfo)\n  }\n\n  json() {\n    log.verbose('to json', this.rnfbResp, this.rnfbRespInfo)\n    this.bodyUsed = true\n    return readJSON(this.rnfbResp, this.rnfbRespInfo)\n  }\n\n  blob() {\n    log.verbose('to blob', this.rnfbResp, this.rnfbRespInfo)\n    this.bodyUsed = true\n    return readBlob(this.rnfbResp, this.rnfbRespInfo)\n  }\n}\n\n/**\n * Get response data as array.\n * @param  {FetchBlobResponse} resp Response data object from RNFB fetch call.\n * @param  {RNFetchBlobResponseInfo} info Response informations.\n * @return {Promise<Array>}\n */\nfunction readArrayBuffer(resp, info):Promise<Array> {\n  switch (info.rnfbEncode) {\n    case 'path':\n      return resp.readFile('ascii')\n      break\n    default:\n      let buffer = []\n      let str = resp.text()\n      for (let i in str) {\n        buffer[i] = str.charCodeAt(i);\n      }\n      return Promise.resolve(buffer)\n      break\n  }\n}\n\n/**\n * Get response data as string.\n * @param  {FetchBlobResponse} resp Response data object from RNFB fetch call.\n * @param  {RNFetchBlobResponseInfo} info Response informations.\n * @return {Promise<string>}\n */\nfunction readText(resp, info):Promise<string> {\n  switch (info.rnfbEncode) {\n    case 'base64':\n      return Promise.resolve(resp.text())\n      break\n    case 'path':\n      return resp.text()\n      break\n    default:\n      return Promise.resolve(resp.text())\n      break\n  }\n}\n\n\n/**\n * Get response data as RNFetchBlob Blob polyfill object.\n * @param  {FetchBlobResponse} resp Response data object from RNFB fetch call.\n * @param  {RNFetchBlobResponseInfo} info Response informations.\n * @return {Promise<Blob>}\n */\nfunction readBlob(resp, info):Promise<Blob> {\n  log.verbose('readBlob', resp, info)\n  return resp.blob()\n}\n\n/**\n * Get response data as JSON object.\n * @param  {FetchBlobResponse} resp Response data object from RNFB fetch call.\n * @param  {RNFetchBlobResponseInfo} info Response informations.\n * @return {Promise<object>}\n */\nfunction readJSON(resp, info):Promise<object> {\n  log.verbose('readJSON', resp, info)\n  switch (info.rnfbEncode) {\n    case 'base64':\n      return Promise.resolve(resp.json())\n    case 'path':\n      return resp.json()\n    default:\n      return Promise.resolve(resp.json())\n  }\n}\n"]}]