["2b62e29d4c52fe8ca899b9a6e7118d1b611a6a6e","d329e27e39e99f7083ef2a4ec9a6e9e3b96cd653",[],[],{"version":3,"sources":["/home/giise/candidtwo/node_modules/@firebase/util/dist/cjs/src/subscribe.js"],"names":["Object","defineProperty","exports","value","createSubscribe","executor","onNoObservers","proxy","ObserverProxy","subscribe","bind","_this","observers","unsubscribes","observerCount","task","Promise","resolve","finalized","then","catch","e","error","prototype","next","forEachObserver","observer","close","complete","nextOrObserver","undefined","Error","implementsAnyMethods","noop","unsub","unsubscribeOne","length","finalError","push","i","fn","sendOne","console","err","async","onError","args","_i","arguments","apply","obj","methods","methods_1","method"],"mappings":"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","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Helper to make a Subscribe function (just like Promise helps make a\n * Thenable).\n *\n * @param executor Function which can make calls to a single Observer\n *     as a proxy.\n * @param onNoObservers Callback when count of Observers goes to zero.\n */\nfunction createSubscribe(executor, onNoObservers) {\n    var proxy = new ObserverProxy(executor, onNoObservers);\n    return proxy.subscribe.bind(proxy);\n}\nexports.createSubscribe = createSubscribe;\n/**\n * Implement fan-out for any number of Observers attached via a subscribe\n * function.\n */\nvar ObserverProxy = /** @class */ (function () {\n    /**\n     * @param executor Function which can make calls to a single Observer\n     *     as a proxy.\n     * @param onNoObservers Callback when count of Observers goes to zero.\n     */\n    function ObserverProxy(executor, onNoObservers) {\n        var _this = this;\n        this.observers = [];\n        this.unsubscribes = [];\n        this.observerCount = 0;\n        // Micro-task scheduling by calling task.then().\n        this.task = Promise.resolve();\n        this.finalized = false;\n        this.onNoObservers = onNoObservers;\n        // Call the executor asynchronously so subscribers that are called\n        // synchronously after the creation of the subscribe function\n        // can still receive the very first value generated in the executor.\n        this.task\n            .then(function () {\n            executor(_this);\n        })\n            .catch(function (e) {\n            _this.error(e);\n        });\n    }\n    ObserverProxy.prototype.next = function (value) {\n        this.forEachObserver(function (observer) {\n            observer.next(value);\n        });\n    };\n    ObserverProxy.prototype.error = function (error) {\n        this.forEachObserver(function (observer) {\n            observer.error(error);\n        });\n        this.close(error);\n    };\n    ObserverProxy.prototype.complete = function () {\n        this.forEachObserver(function (observer) {\n            observer.complete();\n        });\n        this.close();\n    };\n    /**\n     * Subscribe function that can be used to add an Observer to the fan-out list.\n     *\n     * - We require that no event is sent to a subscriber sychronously to their\n     *   call to subscribe().\n     */\n    ObserverProxy.prototype.subscribe = function (nextOrObserver, error, complete) {\n        var _this = this;\n        var observer;\n        if (nextOrObserver === undefined &&\n            error === undefined &&\n            complete === undefined) {\n            throw new Error('Missing Observer.');\n        }\n        // Assemble an Observer object when passed as callback functions.\n        if (implementsAnyMethods(nextOrObserver, ['next', 'error', 'complete'])) {\n            observer = nextOrObserver;\n        }\n        else {\n            observer = {\n                next: nextOrObserver,\n                error: error,\n                complete: complete\n            };\n        }\n        if (observer.next === undefined) {\n            observer.next = noop;\n        }\n        if (observer.error === undefined) {\n            observer.error = noop;\n        }\n        if (observer.complete === undefined) {\n            observer.complete = noop;\n        }\n        var unsub = this.unsubscribeOne.bind(this, this.observers.length);\n        // Attempt to subscribe to a terminated Observable - we\n        // just respond to the Observer with the final error or complete\n        // event.\n        if (this.finalized) {\n            this.task.then(function () {\n                try {\n                    if (_this.finalError) {\n                        observer.error(_this.finalError);\n                    }\n                    else {\n                        observer.complete();\n                    }\n                }\n                catch (e) {\n                    // nothing\n                }\n                return;\n            });\n        }\n        this.observers.push(observer);\n        return unsub;\n    };\n    // Unsubscribe is synchronous - we guarantee that no events are sent to\n    // any unsubscribed Observer.\n    ObserverProxy.prototype.unsubscribeOne = function (i) {\n        if (this.observers === undefined || this.observers[i] === undefined) {\n            return;\n        }\n        delete this.observers[i];\n        this.observerCount -= 1;\n        if (this.observerCount === 0 && this.onNoObservers !== undefined) {\n            this.onNoObservers(this);\n        }\n    };\n    ObserverProxy.prototype.forEachObserver = function (fn) {\n        if (this.finalized) {\n            // Already closed by previous event....just eat the additional values.\n            return;\n        }\n        // Since sendOne calls asynchronously - there is no chance that\n        // this.observers will become undefined.\n        for (var i = 0; i < this.observers.length; i++) {\n            this.sendOne(i, fn);\n        }\n    };\n    // Call the Observer via one of it's callback function. We are careful to\n    // confirm that the observe has not been unsubscribed since this asynchronous\n    // function had been queued.\n    ObserverProxy.prototype.sendOne = function (i, fn) {\n        var _this = this;\n        // Execute the callback asynchronously\n        this.task.then(function () {\n            if (_this.observers !== undefined && _this.observers[i] !== undefined) {\n                try {\n                    fn(_this.observers[i]);\n                }\n                catch (e) {\n                    // Ignore exceptions raised in Observers or missing methods of an\n                    // Observer.\n                    // Log error to console. b/31404806\n                    if (typeof console !== 'undefined' && console.error) {\n                        console.error(e);\n                    }\n                }\n            }\n        });\n    };\n    ObserverProxy.prototype.close = function (err) {\n        var _this = this;\n        if (this.finalized) {\n            return;\n        }\n        this.finalized = true;\n        if (err !== undefined) {\n            this.finalError = err;\n        }\n        // Proxy is no longer needed - garbage collect references\n        this.task.then(function () {\n            _this.observers = undefined;\n            _this.onNoObservers = undefined;\n        });\n    };\n    return ObserverProxy;\n}());\n/** Turn synchronous function into one called asynchronously. */\nfunction async(fn, onError) {\n    return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        Promise.resolve(true)\n            .then(function () {\n            fn.apply(void 0, args);\n        })\n            .catch(function (error) {\n            if (onError) {\n                onError(error);\n            }\n        });\n    };\n}\nexports.async = async;\n/**\n * Return true if the object passed in implements any of the named methods.\n */\nfunction implementsAnyMethods(obj, methods) {\n    if (typeof obj !== 'object' || obj === null) {\n        return false;\n    }\n    for (var _i = 0, methods_1 = methods; _i < methods_1.length; _i++) {\n        var method = methods_1[_i];\n        if (method in obj && typeof obj[method] === 'function') {\n            return true;\n        }\n    }\n    return false;\n}\nfunction noop() {\n    // do nothing\n}\n\n//# sourceMappingURL=subscribe.js.map\n"]}]