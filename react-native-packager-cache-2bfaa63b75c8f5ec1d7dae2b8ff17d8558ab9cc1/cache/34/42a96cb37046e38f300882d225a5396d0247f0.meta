["edb2f84a4ee1bf456b7de548f75f86c9cf7d6952","c2d1e32d87a204752f0eae71d2e9f2b57849c0ec",["../core/util/util","../core/storage/storage","./Constants","./TransportManager"],[99,145,199,248],{"version":3,"sources":["/home/giise/candidtwo/node_modules/@firebase/database/dist/cjs/src/realtime/Connection.js"],"names":["Object","defineProperty","exports","value","util_1","require","storage_1","Constants_1","TransportManager_1","UPGRADE_TIMEOUT","DELAY_BEFORE_SENDING_EXTRA_REQUESTS","BYTES_SENT_HEALTHY_OVERRIDE","BYTES_RECEIVED_HEALTHY_OVERRIDE","MESSAGE_TYPE","MESSAGE_DATA","CONTROL_SHUTDOWN","CONTROL_RESET","CONTROL_ERROR","CONTROL_PONG","SWITCH_ACK","END_TRANSMISSION","PING","SERVER_HELLO","Connection","id","repoInfo_","onMessage_","onReady_","onDisconnect_","onKill_","lastSessionId","connectionCount","pendingDataMessages","state_","log_","logWrapper","transportManager_","TransportManager","start_","prototype","_this","conn","initialTransport","conn_","nextTransportId_","undefined","primaryResponsesRequired_","onMessageReceived","connReceiver_","onConnectionLost","disconnReceiver_","tx_","rx_","secondaryConn_","isHealthy_","setTimeout","open","Math","floor","healthyTimeout_ms","healthyTimeout_","setTimeoutNonBlocking","bytesReceived","markConnectionHealthy","bytesSent","close","everConnected","onConnectionLost_","onSecondaryConnectionLost_","message","onPrimaryMessageReceived_","onSecondaryMessageReceived_","sendRequest","dataMsg","msg","t","d","sendData_","tryCleanupConnection","connId","onSecondaryControl_","controlData","cmd","upgradeIfSecondaryHealthy_","secondaryResponsesRequired_","parsedData","layer","requireKey","data","push","Error","proceedWithUpgrade_","send","start","onControl_","onDataMessage_","onPrimaryResponse_","payload","onHandshake_","i","length","onConnectionShutdown_","onReset_","error","sendPingOnPrimaryIfNecessary_","handshake","timestamp","ts","version","v","host","h","sessionId","s","updateHost","onConnectionEstablished_","PROTOCOL_VERSION","warn","tryStartUpgrade_","upgradeTransport","startUpgrade_","onMessage","onDisconnect","closeConnections_","isCacheableHost","PersistentStorage","remove","internalHost","reason","clearTimeout"],"mappings":"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","sourcesContent":["\"use strict\";\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = require(\"../core/util/util\");\nvar storage_1 = require(\"../core/storage/storage\");\nvar Constants_1 = require(\"./Constants\");\nvar TransportManager_1 = require(\"./TransportManager\");\n// Abort upgrade attempt if it takes longer than 60s.\nvar UPGRADE_TIMEOUT = 60000;\n// For some transports (WebSockets), we need to \"validate\" the transport by exchanging a few requests and responses.\n// If we haven't sent enough requests within 5s, we'll start sending noop ping requests.\nvar DELAY_BEFORE_SENDING_EXTRA_REQUESTS = 5000;\n// If the initial data sent triggers a lot of bandwidth (i.e. it's a large put or a listen for a large amount of data)\n// then we may not be able to exchange our ping/pong requests within the healthy timeout.  So if we reach the timeout\n// but we've sent/received enough bytes, we don't cancel the connection.\nvar BYTES_SENT_HEALTHY_OVERRIDE = 10 * 1024;\nvar BYTES_RECEIVED_HEALTHY_OVERRIDE = 100 * 1024;\nvar MESSAGE_TYPE = 't';\nvar MESSAGE_DATA = 'd';\nvar CONTROL_SHUTDOWN = 's';\nvar CONTROL_RESET = 'r';\nvar CONTROL_ERROR = 'e';\nvar CONTROL_PONG = 'o';\nvar SWITCH_ACK = 'a';\nvar END_TRANSMISSION = 'n';\nvar PING = 'p';\nvar SERVER_HELLO = 'h';\n/**\n * Creates a new real-time connection to the server using whichever method works\n * best in the current browser.\n *\n * @constructor\n */\nvar Connection = /** @class */ (function () {\n    /**\n     * @param {!string} id - an id for this connection\n     * @param {!RepoInfo} repoInfo_ - the info for the endpoint to connect to\n     * @param {function(Object)} onMessage_ - the callback to be triggered when a server-push message arrives\n     * @param {function(number, string)} onReady_ - the callback to be triggered when this connection is ready to send messages.\n     * @param {function()} onDisconnect_ - the callback to be triggered when a connection was lost\n     * @param {function(string)} onKill_ - the callback to be triggered when this connection has permanently shut down.\n     * @param {string=} lastSessionId - last session id in persistent connection. is used to clean up old session in real-time server\n     */\n    function Connection(id, repoInfo_, onMessage_, onReady_, onDisconnect_, onKill_, lastSessionId) {\n        this.id = id;\n        this.repoInfo_ = repoInfo_;\n        this.onMessage_ = onMessage_;\n        this.onReady_ = onReady_;\n        this.onDisconnect_ = onDisconnect_;\n        this.onKill_ = onKill_;\n        this.lastSessionId = lastSessionId;\n        this.connectionCount = 0;\n        this.pendingDataMessages = [];\n        this.state_ = 0 /* CONNECTING */;\n        this.log_ = util_1.logWrapper('c:' + this.id + ':');\n        this.transportManager_ = new TransportManager_1.TransportManager(repoInfo_);\n        this.log_('Connection created');\n        this.start_();\n    }\n    /**\n     * Starts a connection attempt\n     * @private\n     */\n    Connection.prototype.start_ = function () {\n        var _this = this;\n        var conn = this.transportManager_.initialTransport();\n        this.conn_ = new conn(this.nextTransportId_(), this.repoInfo_, undefined, this.lastSessionId);\n        // For certain transports (WebSockets), we need to send and receive several messages back and forth before we\n        // can consider the transport healthy.\n        this.primaryResponsesRequired_ = conn['responsesRequiredToBeHealthy'] || 0;\n        var onMessageReceived = this.connReceiver_(this.conn_);\n        var onConnectionLost = this.disconnReceiver_(this.conn_);\n        this.tx_ = this.conn_;\n        this.rx_ = this.conn_;\n        this.secondaryConn_ = null;\n        this.isHealthy_ = false;\n        /*\n         * Firefox doesn't like when code from one iframe tries to create another iframe by way of the parent frame.\n         * This can occur in the case of a redirect, i.e. we guessed wrong on what server to connect to and received a reset.\n         * Somehow, setTimeout seems to make this ok. That doesn't make sense from a security perspective, since you should\n         * still have the context of your originating frame.\n         */\n        setTimeout(function () {\n            // this.conn_ gets set to null in some of the tests. Check to make sure it still exists before using it\n            _this.conn_ && _this.conn_.open(onMessageReceived, onConnectionLost);\n        }, Math.floor(0));\n        var healthyTimeout_ms = conn['healthyTimeout'] || 0;\n        if (healthyTimeout_ms > 0) {\n            this.healthyTimeout_ = util_1.setTimeoutNonBlocking(function () {\n                _this.healthyTimeout_ = null;\n                if (!_this.isHealthy_) {\n                    if (_this.conn_ &&\n                        _this.conn_.bytesReceived > BYTES_RECEIVED_HEALTHY_OVERRIDE) {\n                        _this.log_('Connection exceeded healthy timeout but has received ' +\n                            _this.conn_.bytesReceived +\n                            ' bytes.  Marking connection healthy.');\n                        _this.isHealthy_ = true;\n                        _this.conn_.markConnectionHealthy();\n                    }\n                    else if (_this.conn_ &&\n                        _this.conn_.bytesSent > BYTES_SENT_HEALTHY_OVERRIDE) {\n                        _this.log_('Connection exceeded healthy timeout but has sent ' +\n                            _this.conn_.bytesSent +\n                            ' bytes.  Leaving connection alive.');\n                        // NOTE: We don't want to mark it healthy, since we have no guarantee that the bytes have made it to\n                        // the server.\n                    }\n                    else {\n                        _this.log_('Closing unhealthy connection after timeout.');\n                        _this.close();\n                    }\n                }\n            }, Math.floor(healthyTimeout_ms));\n        }\n    };\n    /**\n     * @return {!string}\n     * @private\n     */\n    Connection.prototype.nextTransportId_ = function () {\n        return 'c:' + this.id + ':' + this.connectionCount++;\n    };\n    Connection.prototype.disconnReceiver_ = function (conn) {\n        var _this = this;\n        return function (everConnected) {\n            if (conn === _this.conn_) {\n                _this.onConnectionLost_(everConnected);\n            }\n            else if (conn === _this.secondaryConn_) {\n                _this.log_('Secondary connection lost.');\n                _this.onSecondaryConnectionLost_();\n            }\n            else {\n                _this.log_('closing an old connection');\n            }\n        };\n    };\n    Connection.prototype.connReceiver_ = function (conn) {\n        var _this = this;\n        return function (message) {\n            if (_this.state_ != 2 /* DISCONNECTED */) {\n                if (conn === _this.rx_) {\n                    _this.onPrimaryMessageReceived_(message);\n                }\n                else if (conn === _this.secondaryConn_) {\n                    _this.onSecondaryMessageReceived_(message);\n                }\n                else {\n                    _this.log_('message on old connection');\n                }\n            }\n        };\n    };\n    /**\n     *\n     * @param {Object} dataMsg An arbitrary data message to be sent to the server\n     */\n    Connection.prototype.sendRequest = function (dataMsg) {\n        // wrap in a data message envelope and send it on\n        var msg = { t: 'd', d: dataMsg };\n        this.sendData_(msg);\n    };\n    Connection.prototype.tryCleanupConnection = function () {\n        if (this.tx_ === this.secondaryConn_ && this.rx_ === this.secondaryConn_) {\n            this.log_('cleaning up and promoting a connection: ' + this.secondaryConn_.connId);\n            this.conn_ = this.secondaryConn_;\n            this.secondaryConn_ = null;\n            // the server will shutdown the old connection\n        }\n    };\n    Connection.prototype.onSecondaryControl_ = function (controlData) {\n        if (MESSAGE_TYPE in controlData) {\n            var cmd = controlData[MESSAGE_TYPE];\n            if (cmd === SWITCH_ACK) {\n                this.upgradeIfSecondaryHealthy_();\n            }\n            else if (cmd === CONTROL_RESET) {\n                // Most likely the session wasn't valid. Abandon the switch attempt\n                this.log_('Got a reset on secondary, closing it');\n                this.secondaryConn_.close();\n                // If we were already using this connection for something, than we need to fully close\n                if (this.tx_ === this.secondaryConn_ ||\n                    this.rx_ === this.secondaryConn_) {\n                    this.close();\n                }\n            }\n            else if (cmd === CONTROL_PONG) {\n                this.log_('got pong on secondary.');\n                this.secondaryResponsesRequired_--;\n                this.upgradeIfSecondaryHealthy_();\n            }\n        }\n    };\n    Connection.prototype.onSecondaryMessageReceived_ = function (parsedData) {\n        var layer = util_1.requireKey('t', parsedData);\n        var data = util_1.requireKey('d', parsedData);\n        if (layer == 'c') {\n            this.onSecondaryControl_(data);\n        }\n        else if (layer == 'd') {\n            // got a data message, but we're still second connection. Need to buffer it up\n            this.pendingDataMessages.push(data);\n        }\n        else {\n            throw new Error('Unknown protocol layer: ' + layer);\n        }\n    };\n    Connection.prototype.upgradeIfSecondaryHealthy_ = function () {\n        if (this.secondaryResponsesRequired_ <= 0) {\n            this.log_('Secondary connection is healthy.');\n            this.isHealthy_ = true;\n            this.secondaryConn_.markConnectionHealthy();\n            this.proceedWithUpgrade_();\n        }\n        else {\n            // Send a ping to make sure the connection is healthy.\n            this.log_('sending ping on secondary.');\n            this.secondaryConn_.send({ t: 'c', d: { t: PING, d: {} } });\n        }\n    };\n    Connection.prototype.proceedWithUpgrade_ = function () {\n        // tell this connection to consider itself open\n        this.secondaryConn_.start();\n        // send ack\n        this.log_('sending client ack on secondary');\n        this.secondaryConn_.send({ t: 'c', d: { t: SWITCH_ACK, d: {} } });\n        // send end packet on primary transport, switch to sending on this one\n        // can receive on this one, buffer responses until end received on primary transport\n        this.log_('Ending transmission on primary');\n        this.conn_.send({ t: 'c', d: { t: END_TRANSMISSION, d: {} } });\n        this.tx_ = this.secondaryConn_;\n        this.tryCleanupConnection();\n    };\n    Connection.prototype.onPrimaryMessageReceived_ = function (parsedData) {\n        // Must refer to parsedData properties in quotes, so closure doesn't touch them.\n        var layer = util_1.requireKey('t', parsedData);\n        var data = util_1.requireKey('d', parsedData);\n        if (layer == 'c') {\n            this.onControl_(data);\n        }\n        else if (layer == 'd') {\n            this.onDataMessage_(data);\n        }\n    };\n    Connection.prototype.onDataMessage_ = function (message) {\n        this.onPrimaryResponse_();\n        // We don't do anything with data messages, just kick them up a level\n        this.onMessage_(message);\n    };\n    Connection.prototype.onPrimaryResponse_ = function () {\n        if (!this.isHealthy_) {\n            this.primaryResponsesRequired_--;\n            if (this.primaryResponsesRequired_ <= 0) {\n                this.log_('Primary connection is healthy.');\n                this.isHealthy_ = true;\n                this.conn_.markConnectionHealthy();\n            }\n        }\n    };\n    Connection.prototype.onControl_ = function (controlData) {\n        var cmd = util_1.requireKey(MESSAGE_TYPE, controlData);\n        if (MESSAGE_DATA in controlData) {\n            var payload = controlData[MESSAGE_DATA];\n            if (cmd === SERVER_HELLO) {\n                this.onHandshake_(payload);\n            }\n            else if (cmd === END_TRANSMISSION) {\n                this.log_('recvd end transmission on primary');\n                this.rx_ = this.secondaryConn_;\n                for (var i = 0; i < this.pendingDataMessages.length; ++i) {\n                    this.onDataMessage_(this.pendingDataMessages[i]);\n                }\n                this.pendingDataMessages = [];\n                this.tryCleanupConnection();\n            }\n            else if (cmd === CONTROL_SHUTDOWN) {\n                // This was previously the 'onKill' callback passed to the lower-level connection\n                // payload in this case is the reason for the shutdown. Generally a human-readable error\n                this.onConnectionShutdown_(payload);\n            }\n            else if (cmd === CONTROL_RESET) {\n                // payload in this case is the host we should contact\n                this.onReset_(payload);\n            }\n            else if (cmd === CONTROL_ERROR) {\n                util_1.error('Server Error: ' + payload);\n            }\n            else if (cmd === CONTROL_PONG) {\n                this.log_('got pong on primary.');\n                this.onPrimaryResponse_();\n                this.sendPingOnPrimaryIfNecessary_();\n            }\n            else {\n                util_1.error('Unknown control packet command: ' + cmd);\n            }\n        }\n    };\n    /**\n     *\n     * @param {Object} handshake The handshake data returned from the server\n     * @private\n     */\n    Connection.prototype.onHandshake_ = function (handshake) {\n        var timestamp = handshake.ts;\n        var version = handshake.v;\n        var host = handshake.h;\n        this.sessionId = handshake.s;\n        this.repoInfo_.updateHost(host);\n        // if we've already closed the connection, then don't bother trying to progress further\n        if (this.state_ == 0 /* CONNECTING */) {\n            this.conn_.start();\n            this.onConnectionEstablished_(this.conn_, timestamp);\n            if (Constants_1.PROTOCOL_VERSION !== version) {\n                util_1.warn('Protocol version mismatch detected');\n            }\n            // TODO: do we want to upgrade? when? maybe a delay?\n            this.tryStartUpgrade_();\n        }\n    };\n    Connection.prototype.tryStartUpgrade_ = function () {\n        var conn = this.transportManager_.upgradeTransport();\n        if (conn) {\n            this.startUpgrade_(conn);\n        }\n    };\n    Connection.prototype.startUpgrade_ = function (conn) {\n        var _this = this;\n        this.secondaryConn_ = new conn(this.nextTransportId_(), this.repoInfo_, this.sessionId);\n        // For certain transports (WebSockets), we need to send and receive several messages back and forth before we\n        // can consider the transport healthy.\n        this.secondaryResponsesRequired_ =\n            conn['responsesRequiredToBeHealthy'] || 0;\n        var onMessage = this.connReceiver_(this.secondaryConn_);\n        var onDisconnect = this.disconnReceiver_(this.secondaryConn_);\n        this.secondaryConn_.open(onMessage, onDisconnect);\n        // If we haven't successfully upgraded after UPGRADE_TIMEOUT, give up and kill the secondary.\n        util_1.setTimeoutNonBlocking(function () {\n            if (_this.secondaryConn_) {\n                _this.log_('Timed out trying to upgrade.');\n                _this.secondaryConn_.close();\n            }\n        }, Math.floor(UPGRADE_TIMEOUT));\n    };\n    Connection.prototype.onReset_ = function (host) {\n        this.log_('Reset packet received.  New host: ' + host);\n        this.repoInfo_.updateHost(host);\n        // TODO: if we're already \"connected\", we need to trigger a disconnect at the next layer up.\n        // We don't currently support resets after the connection has already been established\n        if (this.state_ === 1 /* CONNECTED */) {\n            this.close();\n        }\n        else {\n            // Close whatever connections we have open and start again.\n            this.closeConnections_();\n            this.start_();\n        }\n    };\n    Connection.prototype.onConnectionEstablished_ = function (conn, timestamp) {\n        var _this = this;\n        this.log_('Realtime connection established.');\n        this.conn_ = conn;\n        this.state_ = 1 /* CONNECTED */;\n        if (this.onReady_) {\n            this.onReady_(timestamp, this.sessionId);\n            this.onReady_ = null;\n        }\n        // If after 5 seconds we haven't sent enough requests to the server to get the connection healthy,\n        // send some pings.\n        if (this.primaryResponsesRequired_ === 0) {\n            this.log_('Primary connection is healthy.');\n            this.isHealthy_ = true;\n        }\n        else {\n            util_1.setTimeoutNonBlocking(function () {\n                _this.sendPingOnPrimaryIfNecessary_();\n            }, Math.floor(DELAY_BEFORE_SENDING_EXTRA_REQUESTS));\n        }\n    };\n    Connection.prototype.sendPingOnPrimaryIfNecessary_ = function () {\n        // If the connection isn't considered healthy yet, we'll send a noop ping packet request.\n        if (!this.isHealthy_ && this.state_ === 1 /* CONNECTED */) {\n            this.log_('sending ping on primary.');\n            this.sendData_({ t: 'c', d: { t: PING, d: {} } });\n        }\n    };\n    Connection.prototype.onSecondaryConnectionLost_ = function () {\n        var conn = this.secondaryConn_;\n        this.secondaryConn_ = null;\n        if (this.tx_ === conn || this.rx_ === conn) {\n            // we are relying on this connection already in some capacity. Therefore, a failure is real\n            this.close();\n        }\n    };\n    /**\n     *\n     * @param {boolean} everConnected Whether or not the connection ever reached a server. Used to determine if\n     * we should flush the host cache\n     * @private\n     */\n    Connection.prototype.onConnectionLost_ = function (everConnected) {\n        this.conn_ = null;\n        // NOTE: IF you're seeing a Firefox error for this line, I think it might be because it's getting\n        // called on window close and RealtimeState.CONNECTING is no longer defined.  Just a guess.\n        if (!everConnected && this.state_ === 0 /* CONNECTING */) {\n            this.log_('Realtime connection failed.');\n            // Since we failed to connect at all, clear any cached entry for this namespace in case the machine went away\n            if (this.repoInfo_.isCacheableHost()) {\n                storage_1.PersistentStorage.remove('host:' + this.repoInfo_.host);\n                // reset the internal host to what we would show the user, i.e. <ns>.firebaseio.com\n                this.repoInfo_.internalHost = this.repoInfo_.host;\n            }\n        }\n        else if (this.state_ === 1 /* CONNECTED */) {\n            this.log_('Realtime connection lost.');\n        }\n        this.close();\n    };\n    /**\n     *\n     * @param {string} reason\n     * @private\n     */\n    Connection.prototype.onConnectionShutdown_ = function (reason) {\n        this.log_('Connection shutdown command received. Shutting down...');\n        if (this.onKill_) {\n            this.onKill_(reason);\n            this.onKill_ = null;\n        }\n        // We intentionally don't want to fire onDisconnect (kill is a different case),\n        // so clear the callback.\n        this.onDisconnect_ = null;\n        this.close();\n    };\n    Connection.prototype.sendData_ = function (data) {\n        if (this.state_ !== 1 /* CONNECTED */) {\n            throw 'Connection is not connected';\n        }\n        else {\n            this.tx_.send(data);\n        }\n    };\n    /**\n     * Cleans up this connection, calling the appropriate callbacks\n     */\n    Connection.prototype.close = function () {\n        if (this.state_ !== 2 /* DISCONNECTED */) {\n            this.log_('Closing realtime connection.');\n            this.state_ = 2 /* DISCONNECTED */;\n            this.closeConnections_();\n            if (this.onDisconnect_) {\n                this.onDisconnect_();\n                this.onDisconnect_ = null;\n            }\n        }\n    };\n    /**\n     *\n     * @private\n     */\n    Connection.prototype.closeConnections_ = function () {\n        this.log_('Shutting down all connections');\n        if (this.conn_) {\n            this.conn_.close();\n            this.conn_ = null;\n        }\n        if (this.secondaryConn_) {\n            this.secondaryConn_.close();\n            this.secondaryConn_ = null;\n        }\n        if (this.healthyTimeout_) {\n            clearTimeout(this.healthyTimeout_);\n            this.healthyTimeout_ = null;\n        }\n    };\n    return Connection;\n}());\nexports.Connection = Connection;\n\n//# sourceMappingURL=Connection.js.map\n"]}]