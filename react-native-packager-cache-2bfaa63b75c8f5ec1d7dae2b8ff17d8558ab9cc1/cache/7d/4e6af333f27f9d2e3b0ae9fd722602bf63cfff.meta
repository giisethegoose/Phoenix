["ccad586661f0ec0cf007fbfa0d9f021e209c121a","6d4dee6a6edd4eac78528c0afd076d2dc1d4813b",["@firebase/util","./util/util","./operation/AckUserWrite","./snap/ChildrenNode","./util/ImmutableTree","./operation/ListenComplete","./operation/Merge","./operation/Operation","./operation/Overwrite","./util/Path","./SyncPoint","./WriteTree"],[99,139,184,242,287,336,392,445,493,545,592,634,676],{"version":3,"sources":["/home/giise/candidtwo/node_modules/@firebase/database/dist/cjs/src/core/SyncTree.js"],"names":["Object","defineProperty","exports","value","util_1","require","util_2","AckUserWrite_1","ChildrenNode_1","util_3","ImmutableTree_1","ListenComplete_1","Merge_1","Operation_1","Overwrite_1","Path_1","SyncPoint_1","WriteTree_1","SyncTree","listenProvider_","syncPointTree_","ImmutableTree","Empty","pendingWriteTree_","WriteTree","tagToQueryMap_","queryToTagMap_","prototype","applyUserOverwrite","path","newData","writeId","visible","addOverwrite","applyOperationToSyncPoints_","Overwrite","OperationSource","User","applyUserMerge","changedChildren","addMerge","changeTree","fromObject","Merge","ackUserWrite","revert","write","getWrite","needToReevaluate","removeWrite","affectedTree_1","snap","set","Path","forEach","children","pathString","node","AckUserWrite","applyServerOverwrite","Server","applyServerMerge","applyListenComplete","ListenComplete","applyTaggedQueryOverwrite","tag","queryKey","queryKeyForTag_","r","parseQueryKey_","queryPath","queryId","relativePath","op","forServerTaggedQuery","applyTaggedOperation_","applyTaggedQueryMerge","applyTaggedListenComplete","addEventRegistration","query","eventRegistration","serverCache","foundAncestorDefaultView","foreachOnPath","pathToSyncPoint","sp","getCompleteServerCache","hasCompleteView","syncPoint","get","SyncPoint","serverCacheComplete","ChildrenNode","EMPTY_NODE","subtree","foreachChild","childName","childSyncPoint","completeCache","updateImmediateChild","viewAlreadyExists","viewExistsForQuery","getQueryParams","loadsAllData","makeQueryKey_","assert","getNextQueryTag_","writesCache","childWrites","events","view","viewForQuery","concat","setupListener_","removeEventRegistration","cancelError","_this","maybeSyncPoint","cancelEvents","queryIdentifier","removedAndEvents","isEmpty","remove","removed","removingDefault","findIndex","covered","findOnPath","parentSyncPoint","newViews","collectDistinctViewsForSubTree_","i","length","newQuery","getQuery","listener","createListenerForView_","startListening","queryForListening_","tagForQuery_","hashFn","onComplete","defaultTag","stopListening","queryToRemove","tagToRemove","removeTags_","calcCompleteEventCache","writeIdsToExclude","includeHiddenSets","writeTree","pathSoFar","fold","maybeChildSyncPoint","childMap","completeView","getCompleteView","views_1","getQueryViews","key","childViews","queries","j","removedQuery","removedQueryKey","removedQueryTag","isDefault","getRef","queriesToStop","queries_1","map","childQueries","queryToStop","cache","getServerCache","hash","status","error","errorForServerCode","toString","splitIndex","indexOf","substr","safeGet","nextQueryTag_","operation","applyOperation","applyOperationHelper_","syncPointTree","applyOperationDescendantsHelper_","getFront","childOperation","operationForChild","childTree","childServerCache","getImmediateChild","childWritesCache","child","inorderTraversal"],"mappings":"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","sourcesContent":["\"use strict\";\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = require(\"@firebase/util\");\nvar util_2 = require(\"./util/util\");\nvar AckUserWrite_1 = require(\"./operation/AckUserWrite\");\nvar ChildrenNode_1 = require(\"./snap/ChildrenNode\");\nvar util_3 = require(\"@firebase/util\");\nvar ImmutableTree_1 = require(\"./util/ImmutableTree\");\nvar ListenComplete_1 = require(\"./operation/ListenComplete\");\nvar Merge_1 = require(\"./operation/Merge\");\nvar Operation_1 = require(\"./operation/Operation\");\nvar Overwrite_1 = require(\"./operation/Overwrite\");\nvar Path_1 = require(\"./util/Path\");\nvar SyncPoint_1 = require(\"./SyncPoint\");\nvar WriteTree_1 = require(\"./WriteTree\");\n/**\n * SyncTree is the central class for managing event callback registration, data caching, views\n * (query processing), and event generation.  There are typically two SyncTree instances for\n * each Repo, one for the normal Firebase data, and one for the .info data.\n *\n * It has a number of responsibilities, including:\n *  - Tracking all user event callbacks (registered via addEventRegistration() and removeEventRegistration()).\n *  - Applying and caching data changes for user set(), transaction(), and update() calls\n *    (applyUserOverwrite(), applyUserMerge()).\n *  - Applying and caching data changes for server data changes (applyServerOverwrite(),\n *    applyServerMerge()).\n *  - Generating user-facing events for server and user changes (all of the apply* methods\n *    return the set of events that need to be raised as a result).\n *  - Maintaining the appropriate set of server listens to ensure we are always subscribed\n *    to the correct set of paths and queries to satisfy the current set of user event\n *    callbacks (listens are started/stopped using the provided listenProvider).\n *\n * NOTE: Although SyncTree tracks event callbacks and calculates events to raise, the actual\n * events are returned to the caller rather than raised synchronously.\n *\n * @constructor\n */\nvar SyncTree = /** @class */ (function () {\n    /**\n     * @param {!ListenProvider} listenProvider_ Used by SyncTree to start / stop listening\n     *   to server data.\n     */\n    function SyncTree(listenProvider_) {\n        this.listenProvider_ = listenProvider_;\n        /**\n         * Tree of SyncPoints.  There's a SyncPoint at any location that has 1 or more views.\n         * @type {!ImmutableTree.<!SyncPoint>}\n         * @private\n         */\n        this.syncPointTree_ = ImmutableTree_1.ImmutableTree.Empty;\n        /**\n         * A tree of all pending user writes (user-initiated set()'s, transaction()'s, update()'s, etc.).\n         * @type {!WriteTree}\n         * @private\n         */\n        this.pendingWriteTree_ = new WriteTree_1.WriteTree();\n        this.tagToQueryMap_ = {};\n        this.queryToTagMap_ = {};\n    }\n    /**\n     * Apply the data changes for a user-generated set() or transaction() call.\n     *\n     * @param {!Path} path\n     * @param {!Node} newData\n     * @param {number} writeId\n     * @param {boolean=} visible\n     * @return {!Array.<!Event>} Events to raise.\n     */\n    SyncTree.prototype.applyUserOverwrite = function (path, newData, writeId, visible) {\n        // Record pending write.\n        this.pendingWriteTree_.addOverwrite(path, newData, writeId, visible);\n        if (!visible) {\n            return [];\n        }\n        else {\n            return this.applyOperationToSyncPoints_(new Overwrite_1.Overwrite(Operation_1.OperationSource.User, path, newData));\n        }\n    };\n    /**\n     * Apply the data from a user-generated update() call\n     *\n     * @param {!Path} path\n     * @param {!Object.<string, !Node>} changedChildren\n     * @param {!number} writeId\n     * @return {!Array.<!Event>} Events to raise.\n     */\n    SyncTree.prototype.applyUserMerge = function (path, changedChildren, writeId) {\n        // Record pending merge.\n        this.pendingWriteTree_.addMerge(path, changedChildren, writeId);\n        var changeTree = ImmutableTree_1.ImmutableTree.fromObject(changedChildren);\n        return this.applyOperationToSyncPoints_(new Merge_1.Merge(Operation_1.OperationSource.User, path, changeTree));\n    };\n    /**\n     * Acknowledge a pending user write that was previously registered with applyUserOverwrite() or applyUserMerge().\n     *\n     * @param {!number} writeId\n     * @param {boolean=} revert True if the given write failed and needs to be reverted\n     * @return {!Array.<!Event>} Events to raise.\n     */\n    SyncTree.prototype.ackUserWrite = function (writeId, revert) {\n        if (revert === void 0) { revert = false; }\n        var write = this.pendingWriteTree_.getWrite(writeId);\n        var needToReevaluate = this.pendingWriteTree_.removeWrite(writeId);\n        if (!needToReevaluate) {\n            return [];\n        }\n        else {\n            var affectedTree_1 = ImmutableTree_1.ImmutableTree.Empty;\n            if (write.snap != null) {\n                // overwrite\n                affectedTree_1 = affectedTree_1.set(Path_1.Path.Empty, true);\n            }\n            else {\n                util_3.forEach(write.children, function (pathString, node) {\n                    affectedTree_1 = affectedTree_1.set(new Path_1.Path(pathString), node);\n                });\n            }\n            return this.applyOperationToSyncPoints_(new AckUserWrite_1.AckUserWrite(write.path, affectedTree_1, revert));\n        }\n    };\n    /**\n     * Apply new server data for the specified path..\n     *\n     * @param {!Path} path\n     * @param {!Node} newData\n     * @return {!Array.<!Event>} Events to raise.\n     */\n    SyncTree.prototype.applyServerOverwrite = function (path, newData) {\n        return this.applyOperationToSyncPoints_(new Overwrite_1.Overwrite(Operation_1.OperationSource.Server, path, newData));\n    };\n    /**\n     * Apply new server data to be merged in at the specified path.\n     *\n     * @param {!Path} path\n     * @param {!Object.<string, !Node>} changedChildren\n     * @return {!Array.<!Event>} Events to raise.\n     */\n    SyncTree.prototype.applyServerMerge = function (path, changedChildren) {\n        var changeTree = ImmutableTree_1.ImmutableTree.fromObject(changedChildren);\n        return this.applyOperationToSyncPoints_(new Merge_1.Merge(Operation_1.OperationSource.Server, path, changeTree));\n    };\n    /**\n     * Apply a listen complete for a query\n     *\n     * @param {!Path} path\n     * @return {!Array.<!Event>} Events to raise.\n     */\n    SyncTree.prototype.applyListenComplete = function (path) {\n        return this.applyOperationToSyncPoints_(new ListenComplete_1.ListenComplete(Operation_1.OperationSource.Server, path));\n    };\n    /**\n     * Apply new server data for the specified tagged query.\n     *\n     * @param {!Path} path\n     * @param {!Node} snap\n     * @param {!number} tag\n     * @return {!Array.<!Event>} Events to raise.\n     */\n    SyncTree.prototype.applyTaggedQueryOverwrite = function (path, snap, tag) {\n        var queryKey = this.queryKeyForTag_(tag);\n        if (queryKey != null) {\n            var r = SyncTree.parseQueryKey_(queryKey);\n            var queryPath = r.path, queryId = r.queryId;\n            var relativePath = Path_1.Path.relativePath(queryPath, path);\n            var op = new Overwrite_1.Overwrite(Operation_1.OperationSource.forServerTaggedQuery(queryId), relativePath, snap);\n            return this.applyTaggedOperation_(queryPath, op);\n        }\n        else {\n            // Query must have been removed already\n            return [];\n        }\n    };\n    /**\n     * Apply server data to be merged in for the specified tagged query.\n     *\n     * @param {!Path} path\n     * @param {!Object.<string, !Node>} changedChildren\n     * @param {!number} tag\n     * @return {!Array.<!Event>} Events to raise.\n     */\n    SyncTree.prototype.applyTaggedQueryMerge = function (path, changedChildren, tag) {\n        var queryKey = this.queryKeyForTag_(tag);\n        if (queryKey) {\n            var r = SyncTree.parseQueryKey_(queryKey);\n            var queryPath = r.path, queryId = r.queryId;\n            var relativePath = Path_1.Path.relativePath(queryPath, path);\n            var changeTree = ImmutableTree_1.ImmutableTree.fromObject(changedChildren);\n            var op = new Merge_1.Merge(Operation_1.OperationSource.forServerTaggedQuery(queryId), relativePath, changeTree);\n            return this.applyTaggedOperation_(queryPath, op);\n        }\n        else {\n            // We've already removed the query. No big deal, ignore the update\n            return [];\n        }\n    };\n    /**\n     * Apply a listen complete for a tagged query\n     *\n     * @param {!Path} path\n     * @param {!number} tag\n     * @return {!Array.<!Event>} Events to raise.\n     */\n    SyncTree.prototype.applyTaggedListenComplete = function (path, tag) {\n        var queryKey = this.queryKeyForTag_(tag);\n        if (queryKey) {\n            var r = SyncTree.parseQueryKey_(queryKey);\n            var queryPath = r.path, queryId = r.queryId;\n            var relativePath = Path_1.Path.relativePath(queryPath, path);\n            var op = new ListenComplete_1.ListenComplete(Operation_1.OperationSource.forServerTaggedQuery(queryId), relativePath);\n            return this.applyTaggedOperation_(queryPath, op);\n        }\n        else {\n            // We've already removed the query. No big deal, ignore the update\n            return [];\n        }\n    };\n    /**\n     * Add an event callback for the specified query.\n     *\n     * @param {!Query} query\n     * @param {!EventRegistration} eventRegistration\n     * @return {!Array.<!Event>} Events to raise.\n     */\n    SyncTree.prototype.addEventRegistration = function (query, eventRegistration) {\n        var path = query.path;\n        var serverCache = null;\n        var foundAncestorDefaultView = false;\n        // Any covering writes will necessarily be at the root, so really all we need to find is the server cache.\n        // Consider optimizing this once there's a better understanding of what actual behavior will be.\n        this.syncPointTree_.foreachOnPath(path, function (pathToSyncPoint, sp) {\n            var relativePath = Path_1.Path.relativePath(pathToSyncPoint, path);\n            serverCache = serverCache || sp.getCompleteServerCache(relativePath);\n            foundAncestorDefaultView =\n                foundAncestorDefaultView || sp.hasCompleteView();\n        });\n        var syncPoint = this.syncPointTree_.get(path);\n        if (!syncPoint) {\n            syncPoint = new SyncPoint_1.SyncPoint();\n            this.syncPointTree_ = this.syncPointTree_.set(path, syncPoint);\n        }\n        else {\n            foundAncestorDefaultView =\n                foundAncestorDefaultView || syncPoint.hasCompleteView();\n            serverCache = serverCache || syncPoint.getCompleteServerCache(Path_1.Path.Empty);\n        }\n        var serverCacheComplete;\n        if (serverCache != null) {\n            serverCacheComplete = true;\n        }\n        else {\n            serverCacheComplete = false;\n            serverCache = ChildrenNode_1.ChildrenNode.EMPTY_NODE;\n            var subtree = this.syncPointTree_.subtree(path);\n            subtree.foreachChild(function (childName, childSyncPoint) {\n                var completeCache = childSyncPoint.getCompleteServerCache(Path_1.Path.Empty);\n                if (completeCache) {\n                    serverCache = serverCache.updateImmediateChild(childName, completeCache);\n                }\n            });\n        }\n        var viewAlreadyExists = syncPoint.viewExistsForQuery(query);\n        if (!viewAlreadyExists && !query.getQueryParams().loadsAllData()) {\n            // We need to track a tag for this query\n            var queryKey = SyncTree.makeQueryKey_(query);\n            util_1.assert(!(queryKey in this.queryToTagMap_), 'View does not exist, but we have a tag');\n            var tag = SyncTree.getNextQueryTag_();\n            this.queryToTagMap_[queryKey] = tag;\n            // Coerce to string to avoid sparse arrays.\n            this.tagToQueryMap_['_' + tag] = queryKey;\n        }\n        var writesCache = this.pendingWriteTree_.childWrites(path);\n        var events = syncPoint.addEventRegistration(query, eventRegistration, writesCache, serverCache, serverCacheComplete);\n        if (!viewAlreadyExists && !foundAncestorDefaultView) {\n            var view /** @type !View */ = syncPoint.viewForQuery(query);\n            events = events.concat(this.setupListener_(query, view));\n        }\n        return events;\n    };\n    /**\n     * Remove event callback(s).\n     *\n     * If query is the default query, we'll check all queries for the specified eventRegistration.\n     * If eventRegistration is null, we'll remove all callbacks for the specified query/queries.\n     *\n     * @param {!Query} query\n     * @param {?EventRegistration} eventRegistration If null, all callbacks are removed.\n     * @param {Error=} cancelError If a cancelError is provided, appropriate cancel events will be returned.\n     * @return {!Array.<!Event>} Cancel events, if cancelError was provided.\n     */\n    SyncTree.prototype.removeEventRegistration = function (query, eventRegistration, cancelError) {\n        var _this = this;\n        // Find the syncPoint first. Then deal with whether or not it has matching listeners\n        var path = query.path;\n        var maybeSyncPoint = this.syncPointTree_.get(path);\n        var cancelEvents = [];\n        // A removal on a default query affects all queries at that location. A removal on an indexed query, even one without\n        // other query constraints, does *not* affect all queries at that location. So this check must be for 'default', and\n        // not loadsAllData().\n        if (maybeSyncPoint &&\n            (query.queryIdentifier() === 'default' ||\n                maybeSyncPoint.viewExistsForQuery(query))) {\n            /**\n             * @type {{removed: !Array.<!Query>, events: !Array.<!Event>}}\n             */\n            var removedAndEvents = maybeSyncPoint.removeEventRegistration(query, eventRegistration, cancelError);\n            if (maybeSyncPoint.isEmpty()) {\n                this.syncPointTree_ = this.syncPointTree_.remove(path);\n            }\n            var removed = removedAndEvents.removed;\n            cancelEvents = removedAndEvents.events;\n            // We may have just removed one of many listeners and can short-circuit this whole process\n            // We may also not have removed a default listener, in which case all of the descendant listeners should already be\n            // properly set up.\n            //\n            // Since indexed queries can shadow if they don't have other query constraints, check for loadsAllData(), instead of\n            // queryId === 'default'\n            var removingDefault = -1 !==\n                removed.findIndex(function (query) {\n                    return query.getQueryParams().loadsAllData();\n                });\n            var covered = this.syncPointTree_.findOnPath(path, function (relativePath, parentSyncPoint) {\n                return parentSyncPoint.hasCompleteView();\n            });\n            if (removingDefault && !covered) {\n                var subtree = this.syncPointTree_.subtree(path);\n                // There are potentially child listeners. Determine what if any listens we need to send before executing the\n                // removal\n                if (!subtree.isEmpty()) {\n                    // We need to fold over our subtree and collect the listeners to send\n                    var newViews = this.collectDistinctViewsForSubTree_(subtree);\n                    // Ok, we've collected all the listens we need. Set them up.\n                    for (var i = 0; i < newViews.length; ++i) {\n                        var view = newViews[i], newQuery = view.getQuery();\n                        var listener = this.createListenerForView_(view);\n                        this.listenProvider_.startListening(SyncTree.queryForListening_(newQuery), this.tagForQuery_(newQuery), listener.hashFn, listener.onComplete);\n                    }\n                }\n                else {\n                    // There's nothing below us, so nothing we need to start listening on\n                }\n            }\n            // If we removed anything and we're not covered by a higher up listen, we need to stop listening on this query\n            // The above block has us covered in terms of making sure we're set up on listens lower in the tree.\n            // Also, note that if we have a cancelError, it's already been removed at the provider level.\n            if (!covered && removed.length > 0 && !cancelError) {\n                // If we removed a default, then we weren't listening on any of the other queries here. Just cancel the one\n                // default. Otherwise, we need to iterate through and cancel each individual query\n                if (removingDefault) {\n                    // We don't tag default listeners\n                    var defaultTag = null;\n                    this.listenProvider_.stopListening(SyncTree.queryForListening_(query), defaultTag);\n                }\n                else {\n                    removed.forEach(function (queryToRemove) {\n                        var tagToRemove = _this.queryToTagMap_[SyncTree.makeQueryKey_(queryToRemove)];\n                        _this.listenProvider_.stopListening(SyncTree.queryForListening_(queryToRemove), tagToRemove);\n                    });\n                }\n            }\n            // Now, clear all of the tags we're tracking for the removed listens\n            this.removeTags_(removed);\n        }\n        else {\n            // No-op, this listener must've been already removed\n        }\n        return cancelEvents;\n    };\n    /**\n     * Returns a complete cache, if we have one, of the data at a particular path. The location must have a listener above\n     * it, but as this is only used by transaction code, that should always be the case anyways.\n     *\n     * Note: this method will *include* hidden writes from transaction with applyLocally set to false.\n     * @param {!Path} path The path to the data we want\n     * @param {Array.<number>=} writeIdsToExclude A specific set to be excluded\n     * @return {?Node}\n     */\n    SyncTree.prototype.calcCompleteEventCache = function (path, writeIdsToExclude) {\n        var includeHiddenSets = true;\n        var writeTree = this.pendingWriteTree_;\n        var serverCache = this.syncPointTree_.findOnPath(path, function (pathSoFar, syncPoint) {\n            var relativePath = Path_1.Path.relativePath(pathSoFar, path);\n            var serverCache = syncPoint.getCompleteServerCache(relativePath);\n            if (serverCache) {\n                return serverCache;\n            }\n        });\n        return writeTree.calcCompleteEventCache(path, serverCache, writeIdsToExclude, includeHiddenSets);\n    };\n    /**\n     * This collapses multiple unfiltered views into a single view, since we only need a single\n     * listener for them.\n     *\n     * @param {!ImmutableTree.<!SyncPoint>} subtree\n     * @return {!Array.<!View>}\n     * @private\n     */\n    SyncTree.prototype.collectDistinctViewsForSubTree_ = function (subtree) {\n        return subtree.fold(function (relativePath, maybeChildSyncPoint, childMap) {\n            if (maybeChildSyncPoint && maybeChildSyncPoint.hasCompleteView()) {\n                var completeView = maybeChildSyncPoint.getCompleteView();\n                return [completeView];\n            }\n            else {\n                // No complete view here, flatten any deeper listens into an array\n                var views_1 = [];\n                if (maybeChildSyncPoint) {\n                    views_1 = maybeChildSyncPoint.getQueryViews();\n                }\n                util_3.forEach(childMap, function (key, childViews) {\n                    views_1 = views_1.concat(childViews);\n                });\n                return views_1;\n            }\n        });\n    };\n    /**\n     * @param {!Array.<!Query>} queries\n     * @private\n     */\n    SyncTree.prototype.removeTags_ = function (queries) {\n        for (var j = 0; j < queries.length; ++j) {\n            var removedQuery = queries[j];\n            if (!removedQuery.getQueryParams().loadsAllData()) {\n                // We should have a tag for this\n                var removedQueryKey = SyncTree.makeQueryKey_(removedQuery);\n                var removedQueryTag = this.queryToTagMap_[removedQueryKey];\n                delete this.queryToTagMap_[removedQueryKey];\n                delete this.tagToQueryMap_['_' + removedQueryTag];\n            }\n        }\n    };\n    /**\n     * Normalizes a query to a query we send the server for listening\n     * @param {!Query} query\n     * @return {!Query} The normalized query\n     * @private\n     */\n    SyncTree.queryForListening_ = function (query) {\n        if (query.getQueryParams().loadsAllData() &&\n            !query.getQueryParams().isDefault()) {\n            // We treat queries that load all data as default queries\n            // Cast is necessary because ref() technically returns Firebase which is actually fb.api.Firebase which inherits\n            // from Query\n            return /** @type {!Query} */ query.getRef();\n        }\n        else {\n            return query;\n        }\n    };\n    /**\n     * For a given new listen, manage the de-duplication of outstanding subscriptions.\n     *\n     * @param {!Query} query\n     * @param {!View} view\n     * @return {!Array.<!Event>} This method can return events to support synchronous data sources\n     * @private\n     */\n    SyncTree.prototype.setupListener_ = function (query, view) {\n        var path = query.path;\n        var tag = this.tagForQuery_(query);\n        var listener = this.createListenerForView_(view);\n        var events = this.listenProvider_.startListening(SyncTree.queryForListening_(query), tag, listener.hashFn, listener.onComplete);\n        var subtree = this.syncPointTree_.subtree(path);\n        // The root of this subtree has our query. We're here because we definitely need to send a listen for that, but we\n        // may need to shadow other listens as well.\n        if (tag) {\n            util_1.assert(!subtree.value.hasCompleteView(), \"If we're adding a query, it shouldn't be shadowed\");\n        }\n        else {\n            // Shadow everything at or below this location, this is a default listener.\n            var queriesToStop = subtree.fold(function (relativePath, maybeChildSyncPoint, childMap) {\n                if (!relativePath.isEmpty() &&\n                    maybeChildSyncPoint &&\n                    maybeChildSyncPoint.hasCompleteView()) {\n                    return [maybeChildSyncPoint.getCompleteView().getQuery()];\n                }\n                else {\n                    // No default listener here, flatten any deeper queries into an array\n                    var queries_1 = [];\n                    if (maybeChildSyncPoint) {\n                        queries_1 = queries_1.concat(maybeChildSyncPoint.getQueryViews().map(function (view) { return view.getQuery(); }));\n                    }\n                    util_3.forEach(childMap, function (key, childQueries) {\n                        queries_1 = queries_1.concat(childQueries);\n                    });\n                    return queries_1;\n                }\n            });\n            for (var i = 0; i < queriesToStop.length; ++i) {\n                var queryToStop = queriesToStop[i];\n                this.listenProvider_.stopListening(SyncTree.queryForListening_(queryToStop), this.tagForQuery_(queryToStop));\n            }\n        }\n        return events;\n    };\n    /**\n     *\n     * @param {!View} view\n     * @return {{hashFn: function(), onComplete: function(!string, *)}}\n     * @private\n     */\n    SyncTree.prototype.createListenerForView_ = function (view) {\n        var _this = this;\n        var query = view.getQuery();\n        var tag = this.tagForQuery_(query);\n        return {\n            hashFn: function () {\n                var cache = view.getServerCache() || ChildrenNode_1.ChildrenNode.EMPTY_NODE;\n                return cache.hash();\n            },\n            onComplete: function (status) {\n                if (status === 'ok') {\n                    if (tag) {\n                        return _this.applyTaggedListenComplete(query.path, tag);\n                    }\n                    else {\n                        return _this.applyListenComplete(query.path);\n                    }\n                }\n                else {\n                    // If a listen failed, kill all of the listeners here, not just the one that triggered the error.\n                    // Note that this may need to be scoped to just this listener if we change permissions on filtered children\n                    var error = util_2.errorForServerCode(status, query);\n                    return _this.removeEventRegistration(query, \n                    /*eventRegistration*/ null, error);\n                }\n            }\n        };\n    };\n    /**\n     * Given a query, computes a \"queryKey\" suitable for use in our queryToTagMap_.\n     * @private\n     * @param {!Query} query\n     * @return {string}\n     */\n    SyncTree.makeQueryKey_ = function (query) {\n        return query.path.toString() + '$' + query.queryIdentifier();\n    };\n    /**\n     * Given a queryKey (created by makeQueryKey), parse it back into a path and queryId.\n     * @private\n     * @param {!string} queryKey\n     * @return {{queryId: !string, path: !Path}}\n     */\n    SyncTree.parseQueryKey_ = function (queryKey) {\n        var splitIndex = queryKey.indexOf('$');\n        util_1.assert(splitIndex !== -1 && splitIndex < queryKey.length - 1, 'Bad queryKey.');\n        return {\n            queryId: queryKey.substr(splitIndex + 1),\n            path: new Path_1.Path(queryKey.substr(0, splitIndex))\n        };\n    };\n    /**\n     * Return the query associated with the given tag, if we have one\n     * @param {!number} tag\n     * @return {?string}\n     * @private\n     */\n    SyncTree.prototype.queryKeyForTag_ = function (tag) {\n        return this.tagToQueryMap_['_' + tag];\n    };\n    /**\n     * Return the tag associated with the given query.\n     * @param {!Query} query\n     * @return {?number}\n     * @private\n     */\n    SyncTree.prototype.tagForQuery_ = function (query) {\n        var queryKey = SyncTree.makeQueryKey_(query);\n        return util_3.safeGet(this.queryToTagMap_, queryKey);\n    };\n    /**\n     * Static accessor for query tags.\n     * @return {number}\n     * @private\n     */\n    SyncTree.getNextQueryTag_ = function () {\n        return SyncTree.nextQueryTag_++;\n    };\n    /**\n     * A helper method to apply tagged operations\n     *\n     * @param {!Path} queryPath\n     * @param {!Operation} operation\n     * @return {!Array.<!Event>}\n     * @private\n     */\n    SyncTree.prototype.applyTaggedOperation_ = function (queryPath, operation) {\n        var syncPoint = this.syncPointTree_.get(queryPath);\n        util_1.assert(syncPoint, \"Missing sync point for query tag that we're tracking\");\n        var writesCache = this.pendingWriteTree_.childWrites(queryPath);\n        return syncPoint.applyOperation(operation, writesCache, \n        /*serverCache=*/ null);\n    };\n    /**\n     * A helper method that visits all descendant and ancestor SyncPoints, applying the operation.\n     *\n     * NOTES:\n     * - Descendant SyncPoints will be visited first (since we raise events depth-first).\n  \n     * - We call applyOperation() on each SyncPoint passing three things:\n     *   1. A version of the Operation that has been made relative to the SyncPoint location.\n     *   2. A WriteTreeRef of any writes we have cached at the SyncPoint location.\n     *   3. A snapshot Node with cached server data, if we have it.\n  \n     * - We concatenate all of the events returned by each SyncPoint and return the result.\n     *\n     * @param {!Operation} operation\n     * @return {!Array.<!Event>}\n     * @private\n     */\n    SyncTree.prototype.applyOperationToSyncPoints_ = function (operation) {\n        return this.applyOperationHelper_(operation, this.syncPointTree_, \n        /*serverCache=*/ null, this.pendingWriteTree_.childWrites(Path_1.Path.Empty));\n    };\n    /**\n     * Recursive helper for applyOperationToSyncPoints_\n     *\n     * @private\n     * @param {!Operation} operation\n     * @param {ImmutableTree.<!SyncPoint>} syncPointTree\n     * @param {?Node} serverCache\n     * @param {!WriteTreeRef} writesCache\n     * @return {!Array.<!Event>}\n     */\n    SyncTree.prototype.applyOperationHelper_ = function (operation, syncPointTree, serverCache, writesCache) {\n        if (operation.path.isEmpty()) {\n            return this.applyOperationDescendantsHelper_(operation, syncPointTree, serverCache, writesCache);\n        }\n        else {\n            var syncPoint = syncPointTree.get(Path_1.Path.Empty);\n            // If we don't have cached server data, see if we can get it from this SyncPoint.\n            if (serverCache == null && syncPoint != null) {\n                serverCache = syncPoint.getCompleteServerCache(Path_1.Path.Empty);\n            }\n            var events = [];\n            var childName = operation.path.getFront();\n            var childOperation = operation.operationForChild(childName);\n            var childTree = syncPointTree.children.get(childName);\n            if (childTree && childOperation) {\n                var childServerCache = serverCache\n                    ? serverCache.getImmediateChild(childName)\n                    : null;\n                var childWritesCache = writesCache.child(childName);\n                events = events.concat(this.applyOperationHelper_(childOperation, childTree, childServerCache, childWritesCache));\n            }\n            if (syncPoint) {\n                events = events.concat(syncPoint.applyOperation(operation, writesCache, serverCache));\n            }\n            return events;\n        }\n    };\n    /**\n     * Recursive helper for applyOperationToSyncPoints_\n     *\n     * @private\n     * @param {!Operation} operation\n     * @param {ImmutableTree.<!SyncPoint>} syncPointTree\n     * @param {?Node} serverCache\n     * @param {!WriteTreeRef} writesCache\n     * @return {!Array.<!Event>}\n     */\n    SyncTree.prototype.applyOperationDescendantsHelper_ = function (operation, syncPointTree, serverCache, writesCache) {\n        var _this = this;\n        var syncPoint = syncPointTree.get(Path_1.Path.Empty);\n        // If we don't have cached server data, see if we can get it from this SyncPoint.\n        if (serverCache == null && syncPoint != null) {\n            serverCache = syncPoint.getCompleteServerCache(Path_1.Path.Empty);\n        }\n        var events = [];\n        syncPointTree.children.inorderTraversal(function (childName, childTree) {\n            var childServerCache = serverCache\n                ? serverCache.getImmediateChild(childName)\n                : null;\n            var childWritesCache = writesCache.child(childName);\n            var childOperation = operation.operationForChild(childName);\n            if (childOperation) {\n                events = events.concat(_this.applyOperationDescendantsHelper_(childOperation, childTree, childServerCache, childWritesCache));\n            }\n        });\n        if (syncPoint) {\n            events = events.concat(syncPoint.applyOperation(operation, writesCache, serverCache));\n        }\n        return events;\n    };\n    /**\n     * Static tracker for next query tag.\n     * @type {number}\n     * @private\n     */\n    SyncTree.nextQueryTag_ = 1;\n    return SyncTree;\n}());\nexports.SyncTree = SyncTree;\n\n//# sourceMappingURL=SyncTree.js.map\n"]}]