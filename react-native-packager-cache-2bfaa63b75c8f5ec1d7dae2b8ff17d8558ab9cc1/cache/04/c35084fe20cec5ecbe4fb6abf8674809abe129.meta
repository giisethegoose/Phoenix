["1ab0548bda8ffb90b88abd70c51eb75b5d29f380","942963bf1657b55156d881289a72b93a52023a86",["react","prop-types","react-native","./TouchableItem","./TabViewPropTypes"],[979,1061,1159,1206,1322],{"version":3,"sources":["/home/giise/candidtwo/node_modules/react-native-tab-view/src/TabBar.js"],"names":["React","TabBar","props","initialVisibility","scrollEnabled","tabWidth","_getTabWidthFromStyle","tabStyle","layout","width","state","offset","Value","visibility","initialOffset","x","_getScrollAmount","navigationState","index","y","_adjustScroll","_positionListener","subscribe","nextProps","_resetScrollOffset","nextTabWidth","setValue","prevProps","global","requestAnimationFrame","remove","position","routes","maxDistance","_getMaxScrollableDistance","finalTabWidth","_getFinalTabWidth","tabBarWidth","length","inputRange","map","i","translateOutputRange","translateX","add","interpolate","outputRange","extrapolate","styles","tabBar","style","indicatorContainer","transform","_renderIndicator","scroll","tabContent","container","_handleScroll","_handleBeginDrag","_handleEndDrag","_handleMomentumScrollBegin","_handleMomentumScrollEnd","_setRef","route","focused","inputIndex","opacity","multiply","scene","label","_renderLabel","icon","renderIcon","badge","renderBadge","paddingTop","padding","passedTabStyle","flatten","isWidthSet","tabContainerStyle","flex","accessibilityLabel","title","key","testID","accessible","pressColor","pressOpacity","onTabPress","jumpToIndex","tabItem","PureComponent","propTypes","bool","getLabelText","func","renderLabel","renderIndicator","labelStyle","any","defaultProps","toUpperCase","_isManualScroll","_isMomentumScroll","tabLabel","isRTL","indicator","indicatorStyle","_tabWidthCache","cache","endsWith","parseFloat","Math","max","_normalizeScrollValue","value","min","centerDistance","scrollAmount","_scrollView","scrollTo","animated","timing","toValue","duration","start","_adjustOffset","scrollOffset","spring","tension","friction","e","nativeEvent","contentOffset","el","create","overflow","OS","backgroundColor","elevation","shadowColor","shadowOpacity","shadowRadius","hairlineWidth","shadowOffset","height","zIndex","flexDirection","flexWrap","color","margin","flexGrow","alignItems","justifyContent","top","right","left","bottom"],"mappings":"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","sourcesContent":["/* @flow */\n\nimport * as React from 'react';\nimport PropTypes from 'prop-types';\nimport {\n  Animated,\n  StyleSheet,\n  View,\n  Text,\n  ScrollView,\n  Platform,\n  I18nManager,\n} from 'react-native';\nimport TouchableItem from './TouchableItem';\nimport { SceneRendererPropType } from './TabViewPropTypes';\nimport type {\n  Scene,\n  SceneRendererProps,\n  Route,\n  Style,\n} from './TabViewTypeDefinitions';\n\ntype IndicatorProps<T> = SceneRendererProps<T> & {\n  width: Animated.Value,\n};\n\ntype ScrollEvent = {\n  nativeEvent: {\n    contentOffset: {\n      x: number,\n    },\n  },\n};\n\ntype Props<T> = SceneRendererProps<T> & {\n  scrollEnabled?: boolean,\n  pressColor?: string,\n  pressOpacity?: number,\n  getLabelText: (scene: Scene<T>) => ?string,\n  renderLabel?: (scene: Scene<T>) => ?React.Element<any>,\n  renderIcon?: (scene: Scene<T>) => ?React.Element<any>,\n  renderBadge?: (scene: Scene<T>) => ?React.Element<any>,\n  renderIndicator?: (props: IndicatorProps<T>) => ?React.Element<any>,\n  onTabPress?: (scene: Scene<T>) => void,\n  tabStyle?: Style,\n  indicatorStyle?: Style,\n  labelStyle?: Style,\n  style?: Style,\n};\n\ntype State = {\n  offset: Animated.Value,\n  visibility: Animated.Value,\n  initialOffset: { x: number, y: number },\n};\n\nexport default class TabBar<T: Route<*>> extends React.PureComponent<\n  Props<T>,\n  State\n> {\n  static propTypes = {\n    ...SceneRendererPropType,\n    scrollEnabled: PropTypes.bool,\n    pressColor: TouchableItem.propTypes.pressColor,\n    pressOpacity: TouchableItem.propTypes.pressOpacity,\n    getLabelText: PropTypes.func,\n    renderIcon: PropTypes.func,\n    renderLabel: PropTypes.func,\n    renderIndicator: PropTypes.func,\n    onTabPress: PropTypes.func,\n    labelStyle: Text.propTypes.style,\n    style: PropTypes.any,\n  };\n\n  static defaultProps = {\n    getLabelText: ({ route }) =>\n      route.title ? route.title.toUpperCase() : null,\n  };\n\n  constructor(props: Props<T>) {\n    super(props);\n\n    let initialVisibility = 0;\n\n    if (this.props.scrollEnabled === true) {\n      const tabWidth = this._getTabWidthFromStyle(this.props.tabStyle);\n      if (this.props.layout.width || tabWidth) {\n        initialVisibility = 1;\n      }\n    } else {\n      initialVisibility = 1;\n    }\n\n    this.state = {\n      offset: new Animated.Value(0),\n      visibility: new Animated.Value(initialVisibility),\n      initialOffset: {\n        x: this._getScrollAmount(this.props, this.props.navigationState.index),\n        y: 0,\n      },\n    };\n  }\n\n  state: State;\n\n  componentDidMount() {\n    this._adjustScroll(this.props.navigationState.index);\n    this._positionListener = this.props.subscribe(\n      'position',\n      this._adjustScroll\n    );\n  }\n\n  componentWillReceiveProps(nextProps: Props<T>) {\n    if (this.props.navigationState !== nextProps.navigationState) {\n      this._resetScrollOffset(nextProps);\n    }\n\n    const nextTabWidth = this._getTabWidthFromStyle(nextProps.tabStyle);\n\n    if (\n      (this.props.tabStyle !== nextProps.tabStyle && nextTabWidth) ||\n      (this.props.layout.width !== nextProps.layout.width &&\n        nextProps.layout.width)\n    ) {\n      this.state.visibility.setValue(1);\n    }\n  }\n\n  componentDidUpdate(prevProps: Props<T>) {\n    if (\n      this.props.scrollEnabled &&\n      (prevProps.layout !== this.props.layout ||\n        prevProps.tabStyle !== this.props.tabStyle)\n    ) {\n      global.requestAnimationFrame(() =>\n        this._adjustScroll(this.props.navigationState.index)\n      );\n    }\n  }\n\n  componentWillUnmount() {\n    this._positionListener.remove();\n  }\n\n  _positionListener: Object;\n  _scrollView: ?ScrollView;\n  _isManualScroll: boolean = false;\n  _isMomentumScroll: boolean = false;\n\n  _renderLabel = (scene: Scene<*>) => {\n    if (typeof this.props.renderLabel !== 'undefined') {\n      return this.props.renderLabel(scene);\n    }\n    const label = this.props.getLabelText(scene);\n    if (typeof label !== 'string') {\n      return null;\n    }\n    return (\n      <Text style={[styles.tabLabel, this.props.labelStyle]}>{label}</Text>\n    );\n  };\n\n  _renderIndicator = (props: IndicatorProps<T>) => {\n    if (typeof this.props.renderIndicator !== 'undefined') {\n      return this.props.renderIndicator(props);\n    }\n    const { width, position } = props;\n    const translateX = Animated.multiply(\n      Animated.multiply(position, width),\n      I18nManager.isRTL ? -1 : 1\n    );\n    return (\n      <Animated.View\n        style={[\n          styles.indicator,\n          { width, transform: [{ translateX }] },\n          this.props.indicatorStyle,\n        ]}\n      />\n    );\n  };\n\n  _tabWidthCache: ?{ style: any, width: ?number };\n\n  _getTabWidthFromStyle = (style: any) => {\n    if (this._tabWidthCache && this._tabWidthCache.style === style) {\n      return this._tabWidthCache.width;\n    }\n    const passedTabStyle = StyleSheet.flatten(this.props.tabStyle);\n    const cache = {\n      style,\n      width: passedTabStyle ? passedTabStyle.width : null,\n    };\n    this._tabWidthCache = cache;\n    return cache;\n  };\n\n  _getFinalTabWidth = (props: Props<T>) => {\n    const { layout, navigationState } = props;\n    const tabWidth = this._getTabWidthFromStyle(props.tabStyle);\n    if (typeof tabWidth === 'number') {\n      return tabWidth;\n    }\n    if (typeof tabWidth === 'string' && tabWidth.endsWith('%')) {\n      return layout.width * (parseFloat(tabWidth) / 100);\n    }\n    if (props.scrollEnabled) {\n      return layout.width / 5 * 2;\n    }\n    return layout.width / navigationState.routes.length;\n  };\n\n  _getMaxScrollableDistance = (props: Props<T>) => {\n    const { layout, navigationState } = props;\n    if (layout.width === 0) {\n      return 0;\n    }\n    const finalTabWidth = this._getFinalTabWidth(props);\n    const tabBarWidth = finalTabWidth * navigationState.routes.length;\n    const maxDistance = tabBarWidth - layout.width;\n    return Math.max(maxDistance, 0);\n  };\n\n  _normalizeScrollValue = (props: Props<T>, value: number) => {\n    const maxDistance = this._getMaxScrollableDistance(props);\n    return Math.max(Math.min(value, maxDistance), 0);\n  };\n\n  _getScrollAmount = (props: Props<T>, i: number) => {\n    const { layout } = props;\n    const finalTabWidth = this._getFinalTabWidth(props);\n    const centerDistance = finalTabWidth * i + finalTabWidth / 2;\n    const scrollAmount = centerDistance - layout.width / 2;\n    return this._normalizeScrollValue(props, scrollAmount);\n  };\n\n  _resetScrollOffset = (props: Props<T>) => {\n    if (!props.scrollEnabled || !this._scrollView) {\n      return;\n    }\n\n    const scrollAmount = this._getScrollAmount(\n      props,\n      props.navigationState.index\n    );\n    this._scrollView &&\n      this._scrollView.scrollTo({\n        x: scrollAmount,\n        animated: true,\n      });\n    Animated.timing(this.state.offset, {\n      toValue: 0,\n      duration: 150,\n    }).start();\n  };\n\n  _adjustScroll = (index: number) => {\n    if (!this.props.scrollEnabled || !this._scrollView) {\n      return;\n    }\n\n    const scrollAmount = this._getScrollAmount(this.props, index);\n    this._scrollView &&\n      this._scrollView.scrollTo({\n        x: scrollAmount,\n        animated: false,\n      });\n  };\n\n  _adjustOffset = (value: number) => {\n    if (!this._isManualScroll || !this.props.scrollEnabled) {\n      return;\n    }\n\n    const scrollAmount = this._getScrollAmount(\n      this.props,\n      this.props.navigationState.index\n    );\n    const scrollOffset = value - scrollAmount;\n\n    if (this._isMomentumScroll) {\n      Animated.spring(this.state.offset, {\n        toValue: -scrollOffset,\n        tension: 300,\n        friction: 35,\n      }).start();\n    } else {\n      this.state.offset.setValue(-scrollOffset);\n    }\n  };\n\n  _handleScroll = (e: ScrollEvent) => {\n    this._adjustOffset(e.nativeEvent.contentOffset.x);\n  };\n\n  _handleBeginDrag = () => {\n    // onScrollBeginDrag fires when user touches the ScrollView\n    this._isManualScroll = true;\n    this._isMomentumScroll = false;\n  };\n\n  _handleEndDrag = () => {\n    // onScrollEndDrag fires when user lifts his finger\n    // onMomentumScrollBegin fires after touch end\n    // run the logic in next frame so we get onMomentumScrollBegin first\n    global.requestAnimationFrame(() => {\n      if (this._isMomentumScroll) {\n        return;\n      }\n      this._isManualScroll = false;\n    });\n  };\n\n  _handleMomentumScrollBegin = () => {\n    // onMomentumScrollBegin fires on flick, as well as programmatic scroll\n    this._isMomentumScroll = true;\n  };\n\n  _handleMomentumScrollEnd = () => {\n    // onMomentumScrollEnd fires when the scroll finishes\n    this._isMomentumScroll = false;\n    this._isManualScroll = false;\n  };\n\n  _setRef = (el: ?ScrollView) => (this._scrollView = el);\n\n  render() {\n    const { position, navigationState, scrollEnabled } = this.props;\n    const { routes, index } = navigationState;\n    const maxDistance = this._getMaxScrollableDistance(this.props);\n    const finalTabWidth = this._getFinalTabWidth(this.props);\n    const tabBarWidth = finalTabWidth * routes.length;\n\n    // Prepend '-1', so there are always at least 2 items in inputRange\n    const inputRange = [-1, ...routes.map((x, i) => i)];\n    const translateOutputRange = inputRange.map(\n      i => this._getScrollAmount(this.props, i) * -1\n    );\n\n    const translateX = Animated.add(\n      position.interpolate({\n        inputRange,\n        outputRange: translateOutputRange,\n      }),\n      this.state.offset\n    ).interpolate({\n      inputRange: [-maxDistance, 0],\n      outputRange: [-maxDistance, 0],\n      extrapolate: 'clamp',\n    });\n\n    return (\n      <Animated.View style={[styles.tabBar, this.props.style]}>\n        <Animated.View\n          pointerEvents=\"none\"\n          style={[\n            styles.indicatorContainer,\n            scrollEnabled\n              ? { width: tabBarWidth, transform: [{ translateX }] }\n              : null,\n          ]}\n        >\n          {this._renderIndicator({\n            ...this.props,\n            width: new Animated.Value(finalTabWidth),\n          })}\n        </Animated.View>\n        <View style={styles.scroll}>\n          <ScrollView\n            horizontal\n            keyboardShouldPersistTaps=\"always\"\n            scrollEnabled={scrollEnabled}\n            bounces={false}\n            alwaysBounceHorizontal={false}\n            scrollsToTop={false}\n            showsHorizontalScrollIndicator={false}\n            automaticallyAdjustContentInsets={false}\n            overScrollMode=\"never\"\n            contentContainerStyle={[\n              styles.tabContent,\n              scrollEnabled ? null : styles.container,\n            ]}\n            scrollEventThrottle={16}\n            onScroll={this._handleScroll}\n            onScrollBeginDrag={this._handleBeginDrag}\n            onScrollEndDrag={this._handleEndDrag}\n            onMomentumScrollBegin={this._handleMomentumScrollBegin}\n            onMomentumScrollEnd={this._handleMomentumScrollEnd}\n            contentOffset={this.state.initialOffset}\n            ref={this._setRef}\n          >\n            {routes.map((route, i) => {\n              const focused = index === i;\n              const outputRange = inputRange.map(\n                inputIndex => (inputIndex === i ? 1 : 0.7)\n              );\n              const opacity = Animated.multiply(\n                this.state.visibility,\n                position.interpolate({\n                  inputRange,\n                  outputRange,\n                })\n              );\n              const scene = {\n                route,\n                focused,\n                index: i,\n              };\n              const label = this._renderLabel(scene);\n              const icon = this.props.renderIcon\n                ? this.props.renderIcon(scene)\n                : null;\n              const badge = this.props.renderBadge\n                ? this.props.renderBadge(scene)\n                : null;\n\n              const tabStyle = {};\n\n              tabStyle.opacity = opacity;\n\n              if (icon) {\n                if (label) {\n                  tabStyle.paddingTop = 8;\n                } else {\n                  tabStyle.padding = 12;\n                }\n              }\n\n              const passedTabStyle = StyleSheet.flatten(this.props.tabStyle);\n              const isWidthSet =\n                (passedTabStyle &&\n                  typeof passedTabStyle.width !== 'undefined') ||\n                scrollEnabled === true;\n              const tabContainerStyle = {};\n\n              if (isWidthSet) {\n                tabStyle.width = finalTabWidth;\n              }\n\n              if (passedTabStyle && typeof passedTabStyle.flex === 'number') {\n                tabContainerStyle.flex = passedTabStyle.flex;\n              } else if (!isWidthSet) {\n                tabContainerStyle.flex = 1;\n              }\n\n              const accessibilityLabel =\n                route.accessibilityLabel || route.title;\n\n              return (\n                <TouchableItem\n                  borderless\n                  key={route.key}\n                  testID={route.testID}\n                  accessible={route.accessible}\n                  accessibilityLabel={accessibilityLabel}\n                  accessibilityTraits=\"button\"\n                  pressColor={this.props.pressColor}\n                  pressOpacity={this.props.pressOpacity}\n                  delayPressIn={0}\n                  onPress={() => {\n                    // eslint-disable-line react/jsx-no-bind\n                    const { onTabPress, jumpToIndex } = this.props;\n                    jumpToIndex(i);\n                    if (onTabPress) {\n                      onTabPress(scene);\n                    }\n                  }}\n                  style={tabContainerStyle}\n                >\n                  <View pointerEvents=\"none\" style={styles.container}>\n                    <Animated.View\n                      style={[\n                        styles.tabItem,\n                        tabStyle,\n                        passedTabStyle,\n                        styles.container,\n                      ]}\n                    >\n                      {icon}\n                      {label}\n                    </Animated.View>\n                    {badge ? (\n                      <Animated.View\n                        style={[\n                          styles.badge,\n                          { opacity: this.state.visibility },\n                        ]}\n                      >\n                        {badge}\n                      </Animated.View>\n                    ) : null}\n                  </View>\n                </TouchableItem>\n              );\n            })}\n          </ScrollView>\n        </View>\n      </Animated.View>\n    );\n  }\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n  scroll: {\n    overflow: Platform.OS === 'web' ? 'auto' : 'scroll',\n  },\n  tabBar: {\n    backgroundColor: '#2196f3',\n    elevation: 4,\n    shadowColor: 'black',\n    shadowOpacity: 0.1,\n    shadowRadius: StyleSheet.hairlineWidth,\n    shadowOffset: {\n      height: StyleSheet.hairlineWidth,\n    },\n    // We don't need zIndex on Android, disable it since it's buggy\n    zIndex: Platform.OS === 'android' ? 0 : 1,\n  },\n  tabContent: {\n    flexDirection: 'row',\n    flexWrap: 'nowrap',\n  },\n  tabLabel: {\n    backgroundColor: 'transparent',\n    color: 'white',\n    margin: 8,\n  },\n  tabItem: {\n    flexGrow: 1,\n    padding: 8,\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n  badge: {\n    position: 'absolute',\n    top: 0,\n    right: 0,\n  },\n  indicatorContainer: {\n    position: 'absolute',\n    top: 0,\n    left: 0,\n    right: 0,\n    bottom: 0,\n  },\n  indicator: {\n    backgroundColor: '#ffeb3b',\n    position: 'absolute',\n    left: 0,\n    bottom: 0,\n    right: 0,\n    height: 2,\n  },\n});\n"]}]