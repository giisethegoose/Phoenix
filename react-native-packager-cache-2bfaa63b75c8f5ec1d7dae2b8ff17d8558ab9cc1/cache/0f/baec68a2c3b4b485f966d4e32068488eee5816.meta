["44c25b952fbbc6fbb3bad645053dbadce8d99f6c","2788dbca08cbc02cf35f1de4e1ea4ac001656e9d",["./RangedFilter","../../snap/ChildrenNode","../../snap/Node","@firebase/util","../Change"],[107,155,204,245,287],{"version":3,"sources":["/home/giise/candidtwo/node_modules/@firebase/database/dist/cjs/src/core/view/filter/LimitedFilter.js"],"names":["Object","defineProperty","exports","value","RangedFilter_1","require","ChildrenNode_1","Node_1","util_1","Change_1","LimitedFilter","params","rangedFilter_","RangedFilter","index_","getIndex","limit_","getLimit","reverse_","isViewFromLeft","prototype","updateChild","snap","key","newChild","affectedPath","source","optChangeAccumulator","matches","NamedNode","ChildrenNode","EMPTY_NODE","getImmediateChild","equals","numChildren","getIndexedFilter","fullLimitUpdateChild_","updateFullNode","oldSnap","newSnap","filtered","isLeafNode","isEmpty","withIndex","isIndexed","iterator","getReverseIteratorFrom","getEndPost","getIteratorFrom","getStartPost","count","hasNext","next","getNext","inRange","compare","updateImmediateChild","name","node","updatePriority","startPost","endPost","cmp","getReverseIterator","indexCompare_1","getCompare","a","b","getIterator","foundStartPost","newPriority","filtersNodes","childKey","childSnap","changeAccumulator","indexCmp_1","oldEventCache","assert","newChildNamedNode","windowBoundary","getFirstChild","getLastChild","hasChild","oldChildSnap","nextChild","getChildAfterChild","compareNext","remainsInWindow","trackChildChange","Change","childChangedChange","childRemovedChange","newEventCache","nextChildInRange","childAddedChange"],"mappings":"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","sourcesContent":["\"use strict\";\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar RangedFilter_1 = require(\"./RangedFilter\");\nvar ChildrenNode_1 = require(\"../../snap/ChildrenNode\");\nvar Node_1 = require(\"../../snap/Node\");\nvar util_1 = require(\"@firebase/util\");\nvar Change_1 = require(\"../Change\");\n/**\n * Applies a limit and a range to a node and uses RangedFilter to do the heavy lifting where possible\n *\n * @constructor\n * @implements {NodeFilter}\n */\nvar LimitedFilter = /** @class */ (function () {\n    /**\n     * @param {!QueryParams} params\n     */\n    function LimitedFilter(params) {\n        this.rangedFilter_ = new RangedFilter_1.RangedFilter(params);\n        this.index_ = params.getIndex();\n        this.limit_ = params.getLimit();\n        this.reverse_ = !params.isViewFromLeft();\n    }\n    /**\n     * @inheritDoc\n     */\n    LimitedFilter.prototype.updateChild = function (snap, key, newChild, affectedPath, source, optChangeAccumulator) {\n        if (!this.rangedFilter_.matches(new Node_1.NamedNode(key, newChild))) {\n            newChild = ChildrenNode_1.ChildrenNode.EMPTY_NODE;\n        }\n        if (snap.getImmediateChild(key).equals(newChild)) {\n            // No change\n            return snap;\n        }\n        else if (snap.numChildren() < this.limit_) {\n            return this.rangedFilter_\n                .getIndexedFilter()\n                .updateChild(snap, key, newChild, affectedPath, source, optChangeAccumulator);\n        }\n        else {\n            return this.fullLimitUpdateChild_(snap, key, newChild, source, optChangeAccumulator);\n        }\n    };\n    /**\n     * @inheritDoc\n     */\n    LimitedFilter.prototype.updateFullNode = function (oldSnap, newSnap, optChangeAccumulator) {\n        var filtered;\n        if (newSnap.isLeafNode() || newSnap.isEmpty()) {\n            // Make sure we have a children node with the correct index, not a leaf node;\n            filtered = ChildrenNode_1.ChildrenNode.EMPTY_NODE.withIndex(this.index_);\n        }\n        else {\n            if (this.limit_ * 2 < newSnap.numChildren() &&\n                newSnap.isIndexed(this.index_)) {\n                // Easier to build up a snapshot, since what we're given has more than twice the elements we want\n                filtered = ChildrenNode_1.ChildrenNode.EMPTY_NODE.withIndex(this.index_);\n                // anchor to the startPost, endPost, or last element as appropriate\n                var iterator = void 0;\n                if (this.reverse_) {\n                    iterator = newSnap.getReverseIteratorFrom(this.rangedFilter_.getEndPost(), this.index_);\n                }\n                else {\n                    iterator = newSnap.getIteratorFrom(this.rangedFilter_.getStartPost(), this.index_);\n                }\n                var count = 0;\n                while (iterator.hasNext() && count < this.limit_) {\n                    var next = iterator.getNext();\n                    var inRange = void 0;\n                    if (this.reverse_) {\n                        inRange =\n                            this.index_.compare(this.rangedFilter_.getStartPost(), next) <= 0;\n                    }\n                    else {\n                        inRange =\n                            this.index_.compare(next, this.rangedFilter_.getEndPost()) <= 0;\n                    }\n                    if (inRange) {\n                        filtered = filtered.updateImmediateChild(next.name, next.node);\n                        count++;\n                    }\n                    else {\n                        // if we have reached the end post, we cannot keep adding elemments\n                        break;\n                    }\n                }\n            }\n            else {\n                // The snap contains less than twice the limit. Faster to delete from the snap than build up a new one\n                filtered = newSnap.withIndex(this.index_);\n                // Don't support priorities on queries\n                filtered = filtered.updatePriority(ChildrenNode_1.ChildrenNode.EMPTY_NODE);\n                var startPost = void 0;\n                var endPost = void 0;\n                var cmp = void 0;\n                var iterator = void 0;\n                if (this.reverse_) {\n                    iterator = filtered.getReverseIterator(this.index_);\n                    startPost = this.rangedFilter_.getEndPost();\n                    endPost = this.rangedFilter_.getStartPost();\n                    var indexCompare_1 = this.index_.getCompare();\n                    cmp = function (a, b) { return indexCompare_1(b, a); };\n                }\n                else {\n                    iterator = filtered.getIterator(this.index_);\n                    startPost = this.rangedFilter_.getStartPost();\n                    endPost = this.rangedFilter_.getEndPost();\n                    cmp = this.index_.getCompare();\n                }\n                var count = 0;\n                var foundStartPost = false;\n                while (iterator.hasNext()) {\n                    var next = iterator.getNext();\n                    if (!foundStartPost && cmp(startPost, next) <= 0) {\n                        // start adding\n                        foundStartPost = true;\n                    }\n                    var inRange = foundStartPost && count < this.limit_ && cmp(next, endPost) <= 0;\n                    if (inRange) {\n                        count++;\n                    }\n                    else {\n                        filtered = filtered.updateImmediateChild(next.name, ChildrenNode_1.ChildrenNode.EMPTY_NODE);\n                    }\n                }\n            }\n        }\n        return this.rangedFilter_\n            .getIndexedFilter()\n            .updateFullNode(oldSnap, filtered, optChangeAccumulator);\n    };\n    /**\n     * @inheritDoc\n     */\n    LimitedFilter.prototype.updatePriority = function (oldSnap, newPriority) {\n        // Don't support priorities on queries\n        return oldSnap;\n    };\n    /**\n     * @inheritDoc\n     */\n    LimitedFilter.prototype.filtersNodes = function () {\n        return true;\n    };\n    /**\n     * @inheritDoc\n     */\n    LimitedFilter.prototype.getIndexedFilter = function () {\n        return this.rangedFilter_.getIndexedFilter();\n    };\n    /**\n     * @inheritDoc\n     */\n    LimitedFilter.prototype.getIndex = function () {\n        return this.index_;\n    };\n    /**\n     * @param {!Node} snap\n     * @param {string} childKey\n     * @param {!Node} childSnap\n     * @param {!CompleteChildSource} source\n     * @param {?ChildChangeAccumulator} changeAccumulator\n     * @return {!Node}\n     * @private\n     */\n    LimitedFilter.prototype.fullLimitUpdateChild_ = function (snap, childKey, childSnap, source, changeAccumulator) {\n        // TODO: rename all cache stuff etc to general snap terminology\n        var cmp;\n        if (this.reverse_) {\n            var indexCmp_1 = this.index_.getCompare();\n            cmp = function (a, b) { return indexCmp_1(b, a); };\n        }\n        else {\n            cmp = this.index_.getCompare();\n        }\n        var oldEventCache = snap;\n        util_1.assert(oldEventCache.numChildren() == this.limit_, '');\n        var newChildNamedNode = new Node_1.NamedNode(childKey, childSnap);\n        var windowBoundary = this.reverse_\n            ? oldEventCache.getFirstChild(this.index_)\n            : oldEventCache.getLastChild(this.index_);\n        var inRange = this.rangedFilter_.matches(newChildNamedNode);\n        if (oldEventCache.hasChild(childKey)) {\n            var oldChildSnap = oldEventCache.getImmediateChild(childKey);\n            var nextChild = source.getChildAfterChild(this.index_, windowBoundary, this.reverse_);\n            while (nextChild != null &&\n                (nextChild.name == childKey || oldEventCache.hasChild(nextChild.name))) {\n                // There is a weird edge case where a node is updated as part of a merge in the write tree, but hasn't\n                // been applied to the limited filter yet. Ignore this next child which will be updated later in\n                // the limited filter...\n                nextChild = source.getChildAfterChild(this.index_, nextChild, this.reverse_);\n            }\n            var compareNext = nextChild == null ? 1 : cmp(nextChild, newChildNamedNode);\n            var remainsInWindow = inRange && !childSnap.isEmpty() && compareNext >= 0;\n            if (remainsInWindow) {\n                if (changeAccumulator != null) {\n                    changeAccumulator.trackChildChange(Change_1.Change.childChangedChange(childKey, childSnap, oldChildSnap));\n                }\n                return oldEventCache.updateImmediateChild(childKey, childSnap);\n            }\n            else {\n                if (changeAccumulator != null) {\n                    changeAccumulator.trackChildChange(Change_1.Change.childRemovedChange(childKey, oldChildSnap));\n                }\n                var newEventCache = oldEventCache.updateImmediateChild(childKey, ChildrenNode_1.ChildrenNode.EMPTY_NODE);\n                var nextChildInRange = nextChild != null && this.rangedFilter_.matches(nextChild);\n                if (nextChildInRange) {\n                    if (changeAccumulator != null) {\n                        changeAccumulator.trackChildChange(Change_1.Change.childAddedChange(nextChild.name, nextChild.node));\n                    }\n                    return newEventCache.updateImmediateChild(nextChild.name, nextChild.node);\n                }\n                else {\n                    return newEventCache;\n                }\n            }\n        }\n        else if (childSnap.isEmpty()) {\n            // we're deleting a node, but it was not in the window, so ignore it\n            return snap;\n        }\n        else if (inRange) {\n            if (cmp(windowBoundary, newChildNamedNode) >= 0) {\n                if (changeAccumulator != null) {\n                    changeAccumulator.trackChildChange(Change_1.Change.childRemovedChange(windowBoundary.name, windowBoundary.node));\n                    changeAccumulator.trackChildChange(Change_1.Change.childAddedChange(childKey, childSnap));\n                }\n                return oldEventCache\n                    .updateImmediateChild(childKey, childSnap)\n                    .updateImmediateChild(windowBoundary.name, ChildrenNode_1.ChildrenNode.EMPTY_NODE);\n            }\n            else {\n                return snap;\n            }\n        }\n        else {\n            return snap;\n        }\n    };\n    return LimitedFilter;\n}());\nexports.LimitedFilter = LimitedFilter;\n\n//# sourceMappingURL=LimitedFilter.js.map\n"]}]