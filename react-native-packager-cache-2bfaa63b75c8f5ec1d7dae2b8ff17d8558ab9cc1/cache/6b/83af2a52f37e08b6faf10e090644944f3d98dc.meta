["86390b3d6ac7e3a7d7cc8b03e993750279898546","c40cb636b0428bcf50ada36303650b2ade8a8e07",["./SortedMap","./Path","./util","@firebase/util"],[104,141,173,205],{"version":3,"sources":["/home/giise/candidtwo/node_modules/@firebase/database/dist/cjs/src/core/util/ImmutableTree.js"],"names":["Object","defineProperty","exports","value","SortedMap_1","require","Path_1","util_1","util_2","emptyChildrenSingleton","EmptyChildren","SortedMap","stringCompare","ImmutableTree","children","fromObject","obj","tree","Empty","forEach","childPath","childSnap","set","Path","prototype","isEmpty","findRootMostMatchingPathAndValue","relativePath","predicate","path","front","getFront","child","get","childExistingPathAndValue","popFront","fullPath","findRootMostValueAndPath","subtree","childTree","toSet","newChild","newChildren","insert","remove","setTree","newTree","fold","fn","fold_","pathSoFar","accum","inorderTraversal","childKey","findOnPath","f","findOnPath_","pathToFollow","result","nextChild","foreachOnPath","foreachOnPath_","currentRelativePath","foreach","foreach_","childName","foreachChild"],"mappings":"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","sourcesContent":["\"use strict\";\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar SortedMap_1 = require(\"./SortedMap\");\nvar Path_1 = require(\"./Path\");\nvar util_1 = require(\"./util\");\nvar util_2 = require(\"@firebase/util\");\nvar emptyChildrenSingleton;\n/**\n * Singleton empty children collection.\n *\n * @const\n * @type {!SortedMap.<string, !ImmutableTree.<?>>}\n */\nvar EmptyChildren = function () {\n    if (!emptyChildrenSingleton) {\n        emptyChildrenSingleton = new SortedMap_1.SortedMap(util_1.stringCompare);\n    }\n    return emptyChildrenSingleton;\n};\n/**\n * A tree with immutable elements.\n */\nvar ImmutableTree = /** @class */ (function () {\n    /**\n     * @template T\n     * @param {?T} value\n     * @param {SortedMap.<string, !ImmutableTree.<T>>=} children\n     */\n    function ImmutableTree(value, children) {\n        if (children === void 0) { children = EmptyChildren(); }\n        this.value = value;\n        this.children = children;\n    }\n    /**\n     * @template T\n     * @param {!Object.<string, !T>} obj\n     * @return {!ImmutableTree.<!T>}\n     */\n    ImmutableTree.fromObject = function (obj) {\n        var tree = ImmutableTree.Empty;\n        util_2.forEach(obj, function (childPath, childSnap) {\n            tree = tree.set(new Path_1.Path(childPath), childSnap);\n        });\n        return tree;\n    };\n    /**\n     * True if the value is empty and there are no children\n     * @return {boolean}\n     */\n    ImmutableTree.prototype.isEmpty = function () {\n        return this.value === null && this.children.isEmpty();\n    };\n    /**\n     * Given a path and predicate, return the first node and the path to that node\n     * where the predicate returns true.\n     *\n     * TODO Do a perf test -- If we're creating a bunch of {path: value:} objects\n     * on the way back out, it may be better to pass down a pathSoFar obj.\n     *\n     * @param {!Path} relativePath The remainder of the path\n     * @param {function(T):boolean} predicate The predicate to satisfy to return a\n     *   node\n     * @return {?{path:!Path, value:!T}}\n     */\n    ImmutableTree.prototype.findRootMostMatchingPathAndValue = function (relativePath, predicate) {\n        if (this.value != null && predicate(this.value)) {\n            return { path: Path_1.Path.Empty, value: this.value };\n        }\n        else {\n            if (relativePath.isEmpty()) {\n                return null;\n            }\n            else {\n                var front = relativePath.getFront();\n                var child = this.children.get(front);\n                if (child !== null) {\n                    var childExistingPathAndValue = child.findRootMostMatchingPathAndValue(relativePath.popFront(), predicate);\n                    if (childExistingPathAndValue != null) {\n                        var fullPath = new Path_1.Path(front).child(childExistingPathAndValue.path);\n                        return { path: fullPath, value: childExistingPathAndValue.value };\n                    }\n                    else {\n                        return null;\n                    }\n                }\n                else {\n                    return null;\n                }\n            }\n        }\n    };\n    /**\n     * Find, if it exists, the shortest subpath of the given path that points a defined\n     * value in the tree\n     * @param {!Path} relativePath\n     * @return {?{path: !Path, value: !T}}\n     */\n    ImmutableTree.prototype.findRootMostValueAndPath = function (relativePath) {\n        return this.findRootMostMatchingPathAndValue(relativePath, function () { return true; });\n    };\n    /**\n     * @param {!Path} relativePath\n     * @return {!ImmutableTree.<T>} The subtree at the given path\n     */\n    ImmutableTree.prototype.subtree = function (relativePath) {\n        if (relativePath.isEmpty()) {\n            return this;\n        }\n        else {\n            var front = relativePath.getFront();\n            var childTree = this.children.get(front);\n            if (childTree !== null) {\n                return childTree.subtree(relativePath.popFront());\n            }\n            else {\n                return ImmutableTree.Empty;\n            }\n        }\n    };\n    /**\n     * Sets a value at the specified path.\n     *\n     * @param {!Path} relativePath Path to set value at.\n     * @param {?T} toSet Value to set.\n     * @return {!ImmutableTree.<T>} Resulting tree.\n     */\n    ImmutableTree.prototype.set = function (relativePath, toSet) {\n        if (relativePath.isEmpty()) {\n            return new ImmutableTree(toSet, this.children);\n        }\n        else {\n            var front = relativePath.getFront();\n            var child = this.children.get(front) || ImmutableTree.Empty;\n            var newChild = child.set(relativePath.popFront(), toSet);\n            var newChildren = this.children.insert(front, newChild);\n            return new ImmutableTree(this.value, newChildren);\n        }\n    };\n    /**\n     * Removes the value at the specified path.\n     *\n     * @param {!Path} relativePath Path to value to remove.\n     * @return {!ImmutableTree.<T>} Resulting tree.\n     */\n    ImmutableTree.prototype.remove = function (relativePath) {\n        if (relativePath.isEmpty()) {\n            if (this.children.isEmpty()) {\n                return ImmutableTree.Empty;\n            }\n            else {\n                return new ImmutableTree(null, this.children);\n            }\n        }\n        else {\n            var front = relativePath.getFront();\n            var child = this.children.get(front);\n            if (child) {\n                var newChild = child.remove(relativePath.popFront());\n                var newChildren = void 0;\n                if (newChild.isEmpty()) {\n                    newChildren = this.children.remove(front);\n                }\n                else {\n                    newChildren = this.children.insert(front, newChild);\n                }\n                if (this.value === null && newChildren.isEmpty()) {\n                    return ImmutableTree.Empty;\n                }\n                else {\n                    return new ImmutableTree(this.value, newChildren);\n                }\n            }\n            else {\n                return this;\n            }\n        }\n    };\n    /**\n     * Gets a value from the tree.\n     *\n     * @param {!Path} relativePath Path to get value for.\n     * @return {?T} Value at path, or null.\n     */\n    ImmutableTree.prototype.get = function (relativePath) {\n        if (relativePath.isEmpty()) {\n            return this.value;\n        }\n        else {\n            var front = relativePath.getFront();\n            var child = this.children.get(front);\n            if (child) {\n                return child.get(relativePath.popFront());\n            }\n            else {\n                return null;\n            }\n        }\n    };\n    /**\n     * Replace the subtree at the specified path with the given new tree.\n     *\n     * @param {!Path} relativePath Path to replace subtree for.\n     * @param {!ImmutableTree} newTree New tree.\n     * @return {!ImmutableTree} Resulting tree.\n     */\n    ImmutableTree.prototype.setTree = function (relativePath, newTree) {\n        if (relativePath.isEmpty()) {\n            return newTree;\n        }\n        else {\n            var front = relativePath.getFront();\n            var child = this.children.get(front) || ImmutableTree.Empty;\n            var newChild = child.setTree(relativePath.popFront(), newTree);\n            var newChildren = void 0;\n            if (newChild.isEmpty()) {\n                newChildren = this.children.remove(front);\n            }\n            else {\n                newChildren = this.children.insert(front, newChild);\n            }\n            return new ImmutableTree(this.value, newChildren);\n        }\n    };\n    /**\n     * Performs a depth first fold on this tree. Transforms a tree into a single\n     * value, given a function that operates on the path to a node, an optional\n     * current value, and a map of child names to folded subtrees\n     * @template V\n     * @param {function(Path, ?T, Object.<string, V>):V} fn\n     * @return {V}\n     */\n    ImmutableTree.prototype.fold = function (fn) {\n        return this.fold_(Path_1.Path.Empty, fn);\n    };\n    /**\n     * Recursive helper for public-facing fold() method\n     * @template V\n     * @param {!Path} pathSoFar\n     * @param {function(Path, ?T, Object.<string, V>):V} fn\n     * @return {V}\n     * @private\n     */\n    ImmutableTree.prototype.fold_ = function (pathSoFar, fn) {\n        var accum = {};\n        this.children.inorderTraversal(function (childKey, childTree) {\n            accum[childKey] = childTree.fold_(pathSoFar.child(childKey), fn);\n        });\n        return fn(pathSoFar, this.value, accum);\n    };\n    /**\n     * Find the first matching value on the given path. Return the result of applying f to it.\n     * @template V\n     * @param {!Path} path\n     * @param {!function(!Path, !T):?V} f\n     * @return {?V}\n     */\n    ImmutableTree.prototype.findOnPath = function (path, f) {\n        return this.findOnPath_(path, Path_1.Path.Empty, f);\n    };\n    ImmutableTree.prototype.findOnPath_ = function (pathToFollow, pathSoFar, f) {\n        var result = this.value ? f(pathSoFar, this.value) : false;\n        if (result) {\n            return result;\n        }\n        else {\n            if (pathToFollow.isEmpty()) {\n                return null;\n            }\n            else {\n                var front = pathToFollow.getFront();\n                var nextChild = this.children.get(front);\n                if (nextChild) {\n                    return nextChild.findOnPath_(pathToFollow.popFront(), pathSoFar.child(front), f);\n                }\n                else {\n                    return null;\n                }\n            }\n        }\n    };\n    /**\n     *\n     * @param {!Path} path\n     * @param {!function(!Path, !T)} f\n     * @returns {!ImmutableTree.<T>}\n     */\n    ImmutableTree.prototype.foreachOnPath = function (path, f) {\n        return this.foreachOnPath_(path, Path_1.Path.Empty, f);\n    };\n    ImmutableTree.prototype.foreachOnPath_ = function (pathToFollow, currentRelativePath, f) {\n        if (pathToFollow.isEmpty()) {\n            return this;\n        }\n        else {\n            if (this.value) {\n                f(currentRelativePath, this.value);\n            }\n            var front = pathToFollow.getFront();\n            var nextChild = this.children.get(front);\n            if (nextChild) {\n                return nextChild.foreachOnPath_(pathToFollow.popFront(), currentRelativePath.child(front), f);\n            }\n            else {\n                return ImmutableTree.Empty;\n            }\n        }\n    };\n    /**\n     * Calls the given function for each node in the tree that has a value.\n     *\n     * @param {function(!Path, !T)} f A function to be called with\n     *   the path from the root of the tree to a node, and the value at that node.\n     *   Called in depth-first order.\n     */\n    ImmutableTree.prototype.foreach = function (f) {\n        this.foreach_(Path_1.Path.Empty, f);\n    };\n    ImmutableTree.prototype.foreach_ = function (currentRelativePath, f) {\n        this.children.inorderTraversal(function (childName, childTree) {\n            childTree.foreach_(currentRelativePath.child(childName), f);\n        });\n        if (this.value) {\n            f(currentRelativePath, this.value);\n        }\n    };\n    /**\n     *\n     * @param {function(string, !T)} f\n     */\n    ImmutableTree.prototype.foreachChild = function (f) {\n        this.children.inorderTraversal(function (childName, childTree) {\n            if (childTree.value) {\n                f(childName, childTree.value);\n            }\n        });\n    };\n    ImmutableTree.Empty = new ImmutableTree(null);\n    return ImmutableTree;\n}());\nexports.ImmutableTree = ImmutableTree;\n\n//# sourceMappingURL=ImmutableTree.js.map\n"]}]