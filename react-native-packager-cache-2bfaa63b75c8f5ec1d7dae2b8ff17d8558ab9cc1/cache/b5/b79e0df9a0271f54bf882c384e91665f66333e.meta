["092d2f8ad4561aad94ac840685741839a17231e8","f50654eb35e750c6db1e266156acfc1ddadd1e86",["@firebase/util","./childSet","./Node","./indexes/PriorityIndex","./indexes/KeyIndex"],[99,143,179,219,260,313],{"version":3,"sources":["/home/giise/candidtwo/node_modules/@firebase/database/dist/cjs/src/core/snap/IndexMap.js"],"names":["Object","defineProperty","exports","value","util_1","require","childSet_1","util_2","Node_1","PriorityIndex_1","KeyIndex_1","_defaultIndexMap","fallbackObject","IndexMap","indexes_","indexSet_","get","assert","PRIORITY_INDEX","enumerable","configurable","prototype","indexKey","sortedMap","safeGet","Error","hasIndex","indexDefinition","contains","toString","addIndex","existingChildren","KEY_INDEX","childList","sawIndexedValue","iter","getIterator","NamedNode","Wrap","next","getNext","isDefinedOn","node","push","newIndex","buildChildSet","getCompare","indexName","newIndexSet","clone","newIndexes","addToIndexes","namedNode","_this","map","indexedChildren","index","name","existingSnap","newChildren","remove","insert","removeFromIndexes"],"mappings":"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","sourcesContent":["\"use strict\";\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar util_1 = require(\"@firebase/util\");\nvar childSet_1 = require(\"./childSet\");\nvar util_2 = require(\"@firebase/util\");\nvar Node_1 = require(\"./Node\");\nvar PriorityIndex_1 = require(\"./indexes/PriorityIndex\");\nvar KeyIndex_1 = require(\"./indexes/KeyIndex\");\nvar _defaultIndexMap;\nvar fallbackObject = {};\n/**\n *\n * @param {Object.<string, FallbackType|SortedMap.<NamedNode, Node>>} indexes\n * @param {Object.<string, Index>} indexSet\n * @constructor\n */\nvar IndexMap = /** @class */ (function () {\n    function IndexMap(indexes_, indexSet_) {\n        this.indexes_ = indexes_;\n        this.indexSet_ = indexSet_;\n    }\n    Object.defineProperty(IndexMap, \"Default\", {\n        /**\n         * The default IndexMap for nodes without a priority\n         * @type {!IndexMap}\n         * @const\n         */\n        get: function () {\n            util_1.assert(fallbackObject && PriorityIndex_1.PRIORITY_INDEX, 'ChildrenNode.ts has not been loaded');\n            _defaultIndexMap =\n                _defaultIndexMap ||\n                    new IndexMap({ '.priority': fallbackObject }, { '.priority': PriorityIndex_1.PRIORITY_INDEX });\n            return _defaultIndexMap;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     *\n     * @param {!string} indexKey\n     * @return {?SortedMap.<NamedNode, Node>}\n     */\n    IndexMap.prototype.get = function (indexKey) {\n        var sortedMap = util_2.safeGet(this.indexes_, indexKey);\n        if (!sortedMap)\n            throw new Error('No index defined for ' + indexKey);\n        if (sortedMap === fallbackObject) {\n            // The index exists, but it falls back to just name comparison. Return null so that the calling code uses the\n            // regular child map\n            return null;\n        }\n        else {\n            return sortedMap;\n        }\n    };\n    /**\n     * @param {!Index} indexDefinition\n     * @return {boolean}\n     */\n    IndexMap.prototype.hasIndex = function (indexDefinition) {\n        return util_2.contains(this.indexSet_, indexDefinition.toString());\n    };\n    /**\n     * @param {!Index} indexDefinition\n     * @param {!SortedMap.<string, !Node>} existingChildren\n     * @return {!IndexMap}\n     */\n    IndexMap.prototype.addIndex = function (indexDefinition, existingChildren) {\n        util_1.assert(indexDefinition !== KeyIndex_1.KEY_INDEX, \"KeyIndex always exists and isn't meant to be added to the IndexMap.\");\n        var childList = [];\n        var sawIndexedValue = false;\n        var iter = existingChildren.getIterator(Node_1.NamedNode.Wrap);\n        var next = iter.getNext();\n        while (next) {\n            sawIndexedValue =\n                sawIndexedValue || indexDefinition.isDefinedOn(next.node);\n            childList.push(next);\n            next = iter.getNext();\n        }\n        var newIndex;\n        if (sawIndexedValue) {\n            newIndex = childSet_1.buildChildSet(childList, indexDefinition.getCompare());\n        }\n        else {\n            newIndex = fallbackObject;\n        }\n        var indexName = indexDefinition.toString();\n        var newIndexSet = util_2.clone(this.indexSet_);\n        newIndexSet[indexName] = indexDefinition;\n        var newIndexes = util_2.clone(this.indexes_);\n        newIndexes[indexName] = newIndex;\n        return new IndexMap(newIndexes, newIndexSet);\n    };\n    /**\n     * Ensure that this node is properly tracked in any indexes that we're maintaining\n     * @param {!NamedNode} namedNode\n     * @param {!SortedMap.<string, !Node>} existingChildren\n     * @return {!IndexMap}\n     */\n    IndexMap.prototype.addToIndexes = function (namedNode, existingChildren) {\n        var _this = this;\n        var newIndexes = util_2.map(this.indexes_, function (indexedChildren, indexName) {\n            var index = util_2.safeGet(_this.indexSet_, indexName);\n            util_1.assert(index, 'Missing index implementation for ' + indexName);\n            if (indexedChildren === fallbackObject) {\n                // Check to see if we need to index everything\n                if (index.isDefinedOn(namedNode.node)) {\n                    // We need to build this index\n                    var childList = [];\n                    var iter = existingChildren.getIterator(Node_1.NamedNode.Wrap);\n                    var next = iter.getNext();\n                    while (next) {\n                        if (next.name != namedNode.name) {\n                            childList.push(next);\n                        }\n                        next = iter.getNext();\n                    }\n                    childList.push(namedNode);\n                    return childSet_1.buildChildSet(childList, index.getCompare());\n                }\n                else {\n                    // No change, this remains a fallback\n                    return fallbackObject;\n                }\n            }\n            else {\n                var existingSnap = existingChildren.get(namedNode.name);\n                var newChildren = indexedChildren;\n                if (existingSnap) {\n                    newChildren = newChildren.remove(new Node_1.NamedNode(namedNode.name, existingSnap));\n                }\n                return newChildren.insert(namedNode, namedNode.node);\n            }\n        });\n        return new IndexMap(newIndexes, this.indexSet_);\n    };\n    /**\n     * Create a new IndexMap instance with the given value removed\n     * @param {!NamedNode} namedNode\n     * @param {!SortedMap.<string, !Node>} existingChildren\n     * @return {!IndexMap}\n     */\n    IndexMap.prototype.removeFromIndexes = function (namedNode, existingChildren) {\n        var newIndexes = util_2.map(this.indexes_, function (indexedChildren) {\n            if (indexedChildren === fallbackObject) {\n                // This is the fallback. Just return it, nothing to do in this case\n                return indexedChildren;\n            }\n            else {\n                var existingSnap = existingChildren.get(namedNode.name);\n                if (existingSnap) {\n                    return indexedChildren.remove(new Node_1.NamedNode(namedNode.name, existingSnap));\n                }\n                else {\n                    // No record of this child\n                    return indexedChildren;\n                }\n            }\n        });\n        return new IndexMap(newIndexes, this.indexSet_);\n    };\n    return IndexMap;\n}());\nexports.IndexMap = IndexMap;\n\n//# sourceMappingURL=IndexMap.js.map\n"]}]