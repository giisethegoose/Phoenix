["21593114d976f926405f2ea4728143ffddef7f78","31e9afc6f4cd53d5754f5f9c76172be7415875d0",["path-to-regexp","../NavigationActions","./createConfigGetter","./getScreenForRouteName","../StateUtils","./validateRouteConfigMap","./getScreenConfigDeprecated"],[1113,1227,1358,1494,1628,1742,1894],{"version":3,"sources":["/home/giise/candidtwo/node_modules/react-navigation/src/routers/StackRouter.js"],"names":["uniqueBaseId","Date","now","uuidCount","_getUuid","routeConfigs","stackConfig","childRouters","routeNames","Object","keys","forEach","routeName","screen","router","initialRouteParams","initialRouteName","initialChildRouter","paths","pathPattern","path","matchExact","re","wildcardRe","RegExp","source","toPath","compile","getComponentForState","state","activeChildRoute","routes","index","getComponentForRouteName","getStateForAction","action","route","type","NAVIGATE","undefined","key","navigate","params","RESET","keyIndex","indexOf","childIndex","childRoute","childRouter","replaceAt","childAction","init","push","childRouterNames","i","length","childRouterName","initChildRoute","navigatedChildRoute","routeToPush","SET_PARAMS","lastRoute","find","resetAction","actions","map","BACK","backRouteIndex","backRoute","pop","slice","getPathAndParamsForState","subPath","stateRoute","child","getActionForPathAndParams","pathToResolve","inputParams","split","pathNameToResolve","queryString","matchedRouteName","pathMatch","pathMatchKeys","entries","exec","nestedAction","nestedQueryString","join","queryParams","reduce","result","item","nextResult","value","matchResult","asterisk","paramName","name","getScreenOptions","navigationOptions","getScreenConfig"],"mappings":";;;;;;;;AAEA;;;;AAEA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;;;;;AAiBA,IAAMA,uBAAqBC,KAAKC,GAAL,EAA3B;AACA,IAAIC,YAAY,CAAhB;AACA,SAASC,QAAT,GAAoB;AAClB,SAAUJ,YAAV,SAA0BG,WAA1B;AACD;;kBAEc,UACbE,YADa,EAOV;AAAA,MALHC,WAKG,uEALwC,EAKxC;;AAEH,wCAAuBD,YAAvB;;AAEA,MAAME,eAAe,EAArB;AACA,MAAMC,aAAaC,OAAOC,IAAP,CAAYL,YAAZ,CAAnB;;AAGAG,aAAWG,OAAX,CAAmB,UAACC,SAAD,EAAuB;AACxC,QAAMC,SAAS,qCAAsBR,YAAtB,EAAoCO,SAApC,CAAf;AACA,QAAIC,UAAUA,OAAOC,MAArB,EAA6B;AAE3BP,mBAAaK,SAAb,IAA0BC,OAAOC,MAAjC;AACD,KAHD,MAGO;AAELP,mBAAaK,SAAb,IAA0B,IAA1B;AACD;AACF,GATD;;AARG,MAmBKG,kBAnBL,GAmB4BT,WAnB5B,CAmBKS,kBAnBL;;;AAqBH,MAAMC,mBAAmBV,YAAYU,gBAAZ,IAAgCR,WAAW,CAAX,CAAzD;;AAEA,MAAMS,qBAAqBV,aAAaS,gBAAb,CAA3B;AACA,MAAME,QAAQZ,YAAYY,KAAZ,IAAqB,EAAnC;;AAGAV,aAAWG,OAAX,CAAmB,UAACC,SAAD,EAAuB;AACxC,QAAIO,cAAcD,MAAMN,SAAN,KAAoBP,aAAaO,SAAb,EAAwBQ,IAA9D;AACA,QAAMC,aAAa,CAAC,CAACF,WAAF,IAAiB,CAACZ,aAAaK,SAAb,CAArC;AACA,QAAI,OAAOO,WAAP,KAAuB,QAA3B,EAAqC;AACnCA,oBAAcP,SAAd;AACD;AACD,QAAMF,OAAO,EAAb;AACA,QAAIY,KAAK,4BAAaH,WAAb,EAA0BT,IAA1B,CAAT;AACA,QAAI,CAACW,UAAL,EAAiB;AACf,UAAME,aAAa,4BAAgBJ,WAAhB,SAAiCT,IAAjC,CAAnB;AACAY,WAAK,IAAIE,MAAJ,SAAiBF,GAAGG,MAApB,aAAkCF,WAAWE,MAA7C,OAAL;AACD;;AAEDP,UAAMN,SAAN,IAAmB,EAAEU,MAAF,EAAMZ,UAAN,EAAYgB,QAAQ,uBAAaC,OAAb,CAAqBR,WAArB,CAApB,EAAnB;AACD,GAdD;;AAgBA,SAAO;AACLS,wBADK,gCACgBC,KADhB,EAC6D;AAChE,UAAMC,mBAAmBD,MAAME,MAAN,CAAaF,MAAMG,KAAnB,CAAzB;AADgE,UAExDpB,SAFwD,GAE1CkB,gBAF0C,CAExDlB,SAFwD;;AAGhE,UAAIL,aAAaK,SAAb,CAAJ,EAA6B;AAC3B,eAAOL,aAAaK,SAAb,EAAwBgB,oBAAxB,CAA6CE,gBAA7C,CAAP;AACD;AACD,aAAO,qCAAsBzB,YAAtB,EAAoCO,SAApC,CAAP;AACD,KARI;AAULqB,4BAVK,oCAUoBrB,SAVpB,EAU4D;AAC/D,aAAO,qCAAsBP,YAAtB,EAAoCO,SAApC,CAAP;AACD,KAZI;AAcLsB,qBAdK,6BAeHC,MAfG,EAgBHN,KAhBG,EAiBe;AAElB,UAAI,CAACA,KAAL,EAAY;AACV,YAAIO,QAAQ,EAAZ;AACA,YACED,OAAOE,IAAP,KAAgB,4BAAkBC,QAAlC,IACA/B,aAAa4B,OAAOvB,SAApB,MAAmC2B,SAFrC,EAGE;AACA,iBAAO;AACLP,mBAAO,CADF;AAELD,oBAAQ,cAEDI,MAFC;AAGJE,oBAAME,SAHF;AAIJC,6BAAapC;AAJT;AAFH,WAAP;AAUD;AACD,YAAIa,kBAAJ,EAAwB;AACtBmB,kBAAQnB,mBAAmBiB,iBAAnB,CACN,4BAAkBO,QAAlB,CAA2B;AACzB7B,uBAAWI,gBADc;AAEzB0B,oBAAQ3B;AAFiB,WAA3B,CADM,CAAR;AAMD;AACD,YAAM2B,SAAS,CAACN,MAAMM,MAAN,IACdP,OAAOO,MADO,IAEd3B,kBAFa,kBAGTqB,MAAMM,MAAN,IAAgB,EAHP,EAITP,OAAOO,MAAP,IAAiB,EAJR,EAKT3B,sBAAsB,EALb,CAAf;AAOAqB,6BACKA,KADL;AAEExB,qBAAWI,gBAFb;AAGEwB,yBAAapC;AAHf,WAIMsC,SAAS,EAAEA,cAAF,EAAT,GAAsB,EAJ5B;;AAOAb,gBAAQ;AACNG,iBAAO,CADD;AAEND,kBAAQ,CAACK,KAAD;AAFF,SAAR;AAID;;AAGD,UAAID,OAAOE,IAAP,KAAgB,4BAAkBM,KAAlC,IAA2CR,OAAOK,GAAP,KAAe,IAA9D,EAAoE;AAClE,YAAMI,WAAWT,OAAOK,GAAP,GACb,qBAAWK,OAAX,CAAmBhB,KAAnB,EAA0BM,OAAOK,GAAjC,CADa,GAEb,CAAC,CAFL;AAGA,YAAMM,aAAaF,YAAY,CAAZ,GAAgBA,QAAhB,GAA2Bf,MAAMG,KAApD;AACA,YAAMe,aAAalB,MAAME,MAAN,CAAae,UAAb,CAAnB;AACA,YAAME,cAAczC,aAAawC,WAAWnC,SAAxB,CAApB;AACA,YAAIoC,WAAJ,EAAiB;AACf,cAAMZ,SAAQY,YAAYd,iBAAZ,CAA8BC,MAA9B,EAAsCY,UAAtC,CAAd;AACA,cAAIX,WAAU,IAAd,EAAoB;AAClB,mBAAOP,KAAP;AACD;AACD,cAAIO,UAASA,WAAUW,UAAvB,EAAmC;AACjC,mBAAO,qBAAWE,SAAX,CAAqBpB,KAArB,EAA4BkB,WAAWP,GAAvC,EAA4CJ,MAA5C,CAAP;AACD;AACF;AACF;;AAGD,UACED,OAAOE,IAAP,KAAgB,4BAAkBC,QAAlC,IACA/B,aAAa4B,OAAOvB,SAApB,MAAmC2B,SAFrC,EAGE;AACA,YAAMS,eAAczC,aAAa4B,OAAOvB,SAApB,CAApB;AACA,YAAIwB,gBAAJ;AACA,YAAIY,YAAJ,EAAiB;AACf,cAAME,cACJf,OAAOA,MAAP,IAAiB,4BAAkBgB,IAAlB,CAAuB,EAAET,QAAQP,OAAOO,MAAjB,EAAvB,CADnB;AAEAN;AACEM,oBAAQP,OAAOO;AADjB,aAEKM,aAAYd,iBAAZ,CAA8BgB,WAA9B,CAFL;AAGEV,iBAAKpC,UAHP;AAIEQ,uBAAWuB,OAAOvB;AAJpB;AAMD,SATD,MASO;AACLwB,oBAAQ;AACNM,oBAAQP,OAAOO,MADT;AAENF,iBAAKpC,UAFC;AAGNQ,uBAAWuB,OAAOvB;AAHZ,WAAR;AAKD;AACD,eAAO,qBAAWwC,IAAX,CAAgBvB,KAAhB,EAAuBO,OAAvB,CAAP;AACD;;AAGD,UAAID,OAAOE,IAAP,KAAgB,4BAAkBC,QAAtC,EAAgD;AAC9C,YAAMe,mBAAmB5C,OAAOC,IAAP,CAAYH,YAAZ,CAAzB;AACA,aAAK,IAAI+C,IAAI,CAAb,EAAgBA,IAAID,iBAAiBE,MAArC,EAA6CD,GAA7C,EAAkD;AAChD,cAAME,kBAAkBH,iBAAiBC,CAAjB,CAAxB;AACA,cAAMN,gBAAczC,aAAaiD,eAAb,CAApB;AACA,cAAIR,aAAJ,EAAiB;AAEf,gBAAMS,iBAAiBT,cAAYd,iBAAZ,CACrB,4BAAkBiB,IAAlB,EADqB,CAAvB;;AAIA,gBAAMO,sBAAsBV,cAAYd,iBAAZ,CAC1BC,MAD0B,EAE1BsB,cAF0B,CAA5B;AAIA,gBAAIE,cAAc,IAAlB;AACA,gBAAID,wBAAwB,IAA5B,EAAkC;AAEhCC,4BAAcF,cAAd;AACD,aAHD,MAGO,IAAIC,wBAAwBD,cAA5B,EAA4C;AAEjDE,4BAAcD,mBAAd;AACD;AACD,gBAAIC,WAAJ,EAAiB;AACf,qBAAO,qBAAWP,IAAX,CAAgBvB,KAAhB,eACF8B,WADE;AAELnB,qBAAKpC,UAFA;AAGLQ,2BAAW4C;AAHN,iBAAP;AAKD;AACF;AACF;AACF;;AAED,UAAIrB,OAAOE,IAAP,KAAgB,4BAAkBuB,UAAtC,EAAkD;AAChD,YAAMpB,MAAML,OAAOK,GAAnB;AACA,YAAMqB,YAAYhC,MAAME,MAAN,CAAa+B,IAAb,CAChB,UAAC1B,KAAD;AAAA,iBAA4BA,MAAMI,GAAN,KAAcA,GAA1C;AAAA,SADgB,CAAlB;AAGA,YAAIqB,SAAJ,EAAe;AACb,cAAMnB,uBACDmB,UAAUnB,MADT,EAEDP,OAAOO,MAFN,CAAN;AAIA,cAAMX,sCAAaF,MAAME,MAAnB,EAAN;AACAA,iBAAOF,MAAME,MAAN,CAAac,OAAb,CAAqBgB,SAArB,CAAP,iBACKA,SADL;AAEEnB;AAFF;AAIA,8BACKb,KADL;AAEEE;AAFF;AAID;AACF;;AAED,UAAII,OAAOE,IAAP,KAAgB,4BAAkBM,KAAtC,EAA6C;AAC3C,YAAMoB,cAAqC5B,MAA3C;;AAEA,4BACKN,KADL;AAEEE,kBAAQgC,YAAYC,OAAZ,CAAoBC,GAApB,CACN,UAACf,WAAD,EAA2C;AACzC,gBAAMpC,SAASP,aAAa2C,YAAYtC,SAAzB,CAAf;AACA,gBAAIE,MAAJ,EAAY;AACV,kCACKoC,WADL,EAEKpC,OAAOoB,iBAAP,CAAyBgB,WAAzB,CAFL;AAGEtC,2BAAWsC,YAAYtC,SAHzB;AAIE4B,qBAAKpC;AAJP;AAMD;AACD,gBAAMgC,qBACDc,WADC;AAEJV,mBAAKpC;AAFD,cAAN;AAIA,mBAAOgC,MAAMC,IAAb;AACA,mBAAOD,KAAP;AACD,WAjBK,CAFV;AAqBEJ,iBAAOG,OAAOH;AArBhB;AAuBD;;AAED,UAAIG,OAAOE,IAAP,KAAgB,4BAAkB6B,IAAtC,EAA4C;AAC1C,YAAM1B,OAAML,OAAOK,GAAnB;AACA,YAAI2B,iBAAiB,IAArB;AACA,YAAI3B,IAAJ,EAAS;AACP,cAAM4B,YAAYvC,MAAME,MAAN,CAAa+B,IAAb,CAChB,UAAC1B,KAAD;AAAA,mBAA4BA,MAAMI,GAAN,KAAcA,IAA1C;AAAA,WADgB,CAAlB;;AAIA2B,2BAAiBtC,MAAME,MAAN,CAAac,OAAb,CAAqBuB,SAArB,CAAjB;AACD;AACD,YAAID,kBAAkB,IAAtB,EAA4B;AAC1B,iBAAO,qBAAWE,GAAX,CAAexC,KAAf,CAAP;AACD;AACD,YAAIsC,iBAAiB,CAArB,EAAwB;AACtB,8BACKtC,KADL;AAEEE,oBAAQF,MAAME,MAAN,CAAauC,KAAb,CAAmB,CAAnB,EAAsBH,cAAtB,CAFV;AAGEnC,mBAAOmC,iBAAiB;AAH1B;AAKD;AACF;AACD,aAAOtC,KAAP;AACD,KAxNI;AA0NL0C,4BA1NK,oCA2NH1C,KA3NG,EA4N0C;AAC7C,UAAMO,QAAQP,MAAME,MAAN,CAAaF,MAAMG,KAAnB,CAAd;AACA,UAAMpB,YAAYwB,MAAMxB,SAAxB;AACA,UAAMC,SAAS,qCAAsBR,YAAtB,EAAoCO,SAApC,CAAf;;AAEA,UAAM4D,UAAUtD,MAAMN,SAAN,EAAiBc,MAAjB,CAAwBU,MAAMM,MAA9B,CAAhB;AACA,UAAItB,OAAOoD,OAAX;AACA,UAAI9B,SAASN,MAAMM,MAAnB;AACA,UAAI7B,UAAUA,OAAOC,MAArB,EAA6B;AAE3B,YAAM2D,aAAmCrC,KAAzC;;AAGA,YAAMsC,QAAQ7D,OAAOC,MAAP,CAAcyD,wBAAd,CAAuCE,UAAvC,CAAd;AACArD,eAAOoD,UAAaA,OAAb,SAAwBE,MAAMtD,IAA9B,GAAuCsD,MAAMtD,IAApD;AACAsB,iBAASgC,MAAMhC,MAAN,gBAAoBA,MAApB,EAA+BgC,MAAMhC,MAArC,IAAgDA,MAAzD;AACD;AACD,aAAO;AACLtB,kBADK;AAELsB;AAFK,OAAP;AAID,KAjPI;AAmPLiC,6BAnPK,qCAoPHC,aApPG,EAqPHC,WArPG,EAsPqB;AAGxB,UAAI,CAACD,aAAL,EAAoB;AAClB,eAAO,4BAAkBnC,QAAlB,CAA2B;AAChC7B,qBAAWI;AADqB,SAA3B,CAAP;AAGD;;AAPuB,iCASiB4D,cAAcE,KAAd,CAAoB,GAApB,CATjB;AAAA;AAAA,UASjBC,iBATiB;AAAA,UASEC,WATF;;AAaxB,UAAIC,yBAAJ;AACA,UAAIC,kBAAJ;AACA,UAAIC,sBAAJ;;AAGA,2BAAgC1E,OAAO2E,OAAP,CAAelE,KAAf,CAAhC,gKAAuD;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;;AAAA,YAA3CN,SAA2C;AAAA,YAAhCQ,IAAgC;AAAA,YAE7CE,EAF6C,GAEhCF,IAFgC,CAE7CE,EAF6C;AAAA,YAEzCZ,IAFyC,GAEhCU,IAFgC,CAEzCV,IAFyC;;AAGrDwE,oBAAY5D,GAAG+D,IAAH,CAAQN,iBAAR,CAAZ;AACA,YAAIG,aAAaA,UAAU3B,MAA3B,EAAmC;AACjC4B,0BAAgBzE,IAAhB;AACAuE,6BAAmBrE,SAAnB;AACA;AACD;AACF;;AAGD,UAAI,CAACqE,gBAAL,EAAuB;AACrB,eAAO,IAAP;AACD;;AAMD,UAAIK,qBAAJ;AACA,UAAIC,oBAAoBP,cAAc,MAAMA,WAApB,GAAkC,EAA1D;AACA,UAAIzE,aAAa0E,gBAAb,CAAJ,EAAoC;AAClCK,uBAAe/E,aAAa0E,gBAAb,EAA+BN,yBAA/B,CAEbO,UAAUZ,KAAV,CAAgBa,cAAc5B,MAA9B,EAAsCiC,IAAtC,CAA2C,GAA3C,IAAkDD,iBAFrC,CAAf;AAID;;AAID,UAAME,cACJZ,eACA,CAACG,eAAe,EAAhB,EAAoBF,KAApB,CAA0B,GAA1B,EAA+BY,MAA/B,CAAsC,UAACC,MAAD,EAAYC,IAAZ,EAA6B;AACjE,YAAIA,SAAS,EAAb,EAAiB;AACf,cAAMC,aAAaF,UAAU,EAA7B;;AADe,4BAEMC,KAAKd,KAAL,CAAW,GAAX,CAFN;AAAA;AAAA,cAERtC,GAFQ;AAAA,cAEHsD,KAFG;;AAGfD,qBAAWrD,GAAX,IAAkBsD,KAAlB;AACA,iBAAOD,UAAP;AACD;AACD,eAAOF,MAAP;AACD,OARD,EAQG,IARH,CAFF;;AAeA,UAAMjD,SAASwC,UACZZ,KADY,CACN,CADM,EAEZoB,MAFY,CAEL,UAACC,MAAD,EAAYI,WAAZ,EAA4BzC,CAA5B,EAA0C;AAChD,YAAMd,MAAM2C,cAAc7B,CAAd,CAAZ;AACA,YAAId,IAAIwD,QAAJ,IAAgB,CAACxD,GAArB,EAA0B;AACxB,iBAAOmD,MAAP;AACD;AACD,YAAME,aAAaF,UAAU,EAA7B;AACA,YAAMM,YAAYzD,IAAI0D,IAAtB;AACAL,mBAAWI,SAAX,IAAwBF,WAAxB;AACA,eAAOF,UAAP;AACD,OAXY,EAWVJ,WAXU,CAAf;;AAaA,aAAO,4BAAkBhD,QAAlB;AACL7B,mBAAWqE;AADN,SAEDvC,SAAS,EAAEA,cAAF,EAAT,GAAsB,EAFrB,EAGD4C,eAAe,EAAEnD,QAAQmD,YAAV,EAAf,GAA0C,EAHzC,EAAP;AAKD,KAxUI;;;AA0ULa,sBAAkB,kCAChB9F,YADgB,EAEhBC,YAAY8F,iBAFI,CA1Ub;;AA+ULC;AA/UK,GAAP;AAiVD,C","sourcesContent":["/* @flow */\n\nimport pathToRegexp from 'path-to-regexp';\n\nimport NavigationActions from '../NavigationActions';\nimport createConfigGetter from './createConfigGetter';\nimport getScreenForRouteName from './getScreenForRouteName';\nimport StateUtils from '../StateUtils';\nimport validateRouteConfigMap from './validateRouteConfigMap';\nimport getScreenConfigDeprecated from './getScreenConfigDeprecated';\n\nimport type {\n  NavigationComponent,\n  NavigationNavigateAction,\n  NavigationRouter,\n  NavigationRouteConfigMap,\n  NavigationResetAction,\n  NavigationParams,\n  NavigationState,\n  NavigationStackAction,\n  NavigationStackRouterConfig,\n  NavigationStackScreenOptions,\n  NavigationRoute,\n  NavigationStateRoute,\n} from '../TypeDefinition';\n\nconst uniqueBaseId = `id-${Date.now()}`;\nlet uuidCount = 0;\nfunction _getUuid() {\n  return `${uniqueBaseId}-${uuidCount++}`;\n}\n\nexport default (\n  routeConfigs: NavigationRouteConfigMap,\n  stackConfig: NavigationStackRouterConfig = {}\n): NavigationRouter<\n  NavigationState,\n  NavigationStackAction,\n  NavigationStackScreenOptions\n> => {\n  // Fail fast on invalid route definitions\n  validateRouteConfigMap(routeConfigs);\n\n  const childRouters = {};\n  const routeNames = Object.keys(routeConfigs);\n\n  // Loop through routes and find child routers\n  routeNames.forEach((routeName: string) => {\n    const screen = getScreenForRouteName(routeConfigs, routeName);\n    if (screen && screen.router) {\n      // If it has a router it's a navigator.\n      childRouters[routeName] = screen.router;\n    } else {\n      // If it doesn't have router it's an ordinary React component.\n      childRouters[routeName] = null;\n    }\n  });\n\n  const { initialRouteParams } = stackConfig;\n\n  const initialRouteName = stackConfig.initialRouteName || routeNames[0];\n\n  const initialChildRouter = childRouters[initialRouteName];\n  const paths = stackConfig.paths || {};\n\n  // Build paths for each route\n  routeNames.forEach((routeName: string) => {\n    let pathPattern = paths[routeName] || routeConfigs[routeName].path;\n    const matchExact = !!pathPattern && !childRouters[routeName];\n    if (typeof pathPattern !== 'string') {\n      pathPattern = routeName;\n    }\n    const keys = [];\n    let re = pathToRegexp(pathPattern, keys);\n    if (!matchExact) {\n      const wildcardRe = pathToRegexp(`${pathPattern}/*`, keys);\n      re = new RegExp(`(?:${re.source})|(?:${wildcardRe.source})`);\n    }\n    /* $FlowFixMe */\n    paths[routeName] = { re, keys, toPath: pathToRegexp.compile(pathPattern) };\n  });\n\n  return {\n    getComponentForState(state: NavigationState): NavigationComponent {\n      const activeChildRoute = state.routes[state.index];\n      const { routeName } = activeChildRoute;\n      if (childRouters[routeName]) {\n        return childRouters[routeName].getComponentForState(activeChildRoute);\n      }\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n\n    getComponentForRouteName(routeName: string): NavigationComponent {\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n\n    getStateForAction(\n      action: NavigationStackAction,\n      state: ?NavigationState\n    ): ?NavigationState {\n      // Set up the initial state if needed\n      if (!state) {\n        let route = {};\n        if (\n          action.type === NavigationActions.NAVIGATE &&\n          childRouters[action.routeName] !== undefined\n        ) {\n          return {\n            index: 0,\n            routes: [\n              {\n                ...action,\n                type: undefined,\n                key: `Init-${_getUuid()}`,\n              },\n            ],\n          };\n        }\n        if (initialChildRouter) {\n          route = initialChildRouter.getStateForAction(\n            NavigationActions.navigate({\n              routeName: initialRouteName,\n              params: initialRouteParams,\n            })\n          );\n        }\n        const params = (route.params ||\n          action.params ||\n          initialRouteParams) && {\n          ...(route.params || {}),\n          ...(action.params || {}),\n          ...(initialRouteParams || {}),\n        };\n        route = {\n          ...route,\n          routeName: initialRouteName,\n          key: `Init-${_getUuid()}`,\n          ...(params ? { params } : {}),\n        };\n        // eslint-disable-next-line no-param-reassign\n        state = {\n          index: 0,\n          routes: [route],\n        };\n      }\n\n      // Check if a child scene wants to handle the action as long as it is not a reset to the root stack\n      if (action.type !== NavigationActions.RESET || action.key !== null) {\n        const keyIndex = action.key\n          ? StateUtils.indexOf(state, action.key)\n          : -1;\n        const childIndex = keyIndex >= 0 ? keyIndex : state.index;\n        const childRoute = state.routes[childIndex];\n        const childRouter = childRouters[childRoute.routeName];\n        if (childRouter) {\n          const route = childRouter.getStateForAction(action, childRoute);\n          if (route === null) {\n            return state;\n          }\n          if (route && route !== childRoute) {\n            return StateUtils.replaceAt(state, childRoute.key, route);\n          }\n        }\n      }\n\n      // Handle explicit push navigation action\n      if (\n        action.type === NavigationActions.NAVIGATE &&\n        childRouters[action.routeName] !== undefined\n      ) {\n        const childRouter = childRouters[action.routeName];\n        let route;\n        if (childRouter) {\n          const childAction =\n            action.action || NavigationActions.init({ params: action.params });\n          route = {\n            params: action.params,\n            ...childRouter.getStateForAction(childAction),\n            key: _getUuid(),\n            routeName: action.routeName,\n          };\n        } else {\n          route = {\n            params: action.params,\n            key: _getUuid(),\n            routeName: action.routeName,\n          };\n        }\n        return StateUtils.push(state, route);\n      }\n\n      // Handle navigation to other child routers that are not yet pushed\n      if (action.type === NavigationActions.NAVIGATE) {\n        const childRouterNames = Object.keys(childRouters);\n        for (let i = 0; i < childRouterNames.length; i++) {\n          const childRouterName = childRouterNames[i];\n          const childRouter = childRouters[childRouterName];\n          if (childRouter) {\n            // For each child router, start with a blank state\n            const initChildRoute = childRouter.getStateForAction(\n              NavigationActions.init()\n            );\n            // Then check to see if the router handles our navigate action\n            const navigatedChildRoute = childRouter.getStateForAction(\n              action,\n              initChildRoute\n            );\n            let routeToPush = null;\n            if (navigatedChildRoute === null) {\n              // Push the route if the router has 'handled' the action and returned null\n              routeToPush = initChildRoute;\n            } else if (navigatedChildRoute !== initChildRoute) {\n              // Push the route if the state has changed in response to this navigation\n              routeToPush = navigatedChildRoute;\n            }\n            if (routeToPush) {\n              return StateUtils.push(state, {\n                ...routeToPush,\n                key: _getUuid(),\n                routeName: childRouterName,\n              });\n            }\n          }\n        }\n      }\n\n      if (action.type === NavigationActions.SET_PARAMS) {\n        const key = action.key;\n        const lastRoute = state.routes.find(\n          (route: NavigationRoute) => route.key === key\n        );\n        if (lastRoute) {\n          const params = {\n            ...lastRoute.params,\n            ...action.params,\n          };\n          const routes = [...state.routes];\n          routes[state.routes.indexOf(lastRoute)] = {\n            ...lastRoute,\n            params,\n          };\n          return {\n            ...state,\n            routes,\n          };\n        }\n      }\n\n      if (action.type === NavigationActions.RESET) {\n        const resetAction: NavigationResetAction = action;\n\n        return {\n          ...state,\n          routes: resetAction.actions.map(\n            (childAction: NavigationNavigateAction) => {\n              const router = childRouters[childAction.routeName];\n              if (router) {\n                return {\n                  ...childAction,\n                  ...router.getStateForAction(childAction),\n                  routeName: childAction.routeName,\n                  key: _getUuid(),\n                };\n              }\n              const route = {\n                ...childAction,\n                key: _getUuid(),\n              };\n              delete route.type;\n              return route;\n            }\n          ),\n          index: action.index,\n        };\n      }\n\n      if (action.type === NavigationActions.BACK) {\n        const key = action.key;\n        let backRouteIndex = null;\n        if (key) {\n          const backRoute = state.routes.find(\n            (route: NavigationRoute) => route.key === key\n          );\n          /* $FlowFixMe */\n          backRouteIndex = state.routes.indexOf(backRoute);\n        }\n        if (backRouteIndex == null) {\n          return StateUtils.pop(state);\n        }\n        if (backRouteIndex > 0) {\n          return {\n            ...state,\n            routes: state.routes.slice(0, backRouteIndex),\n            index: backRouteIndex - 1,\n          };\n        }\n      }\n      return state;\n    },\n\n    getPathAndParamsForState(\n      state: NavigationState\n    ): { path: string, params?: NavigationParams } {\n      const route = state.routes[state.index];\n      const routeName = route.routeName;\n      const screen = getScreenForRouteName(routeConfigs, routeName);\n      /* $FlowFixMe */\n      const subPath = paths[routeName].toPath(route.params);\n      let path = subPath;\n      let params = route.params;\n      if (screen && screen.router) {\n        // $FlowFixMe there's no way type the specific shape of the nav state\n        const stateRoute: NavigationStateRoute = route;\n        // If it has a router it's a navigator.\n        // If it doesn't have router it's an ordinary React component.\n        const child = screen.router.getPathAndParamsForState(stateRoute);\n        path = subPath ? `${subPath}/${child.path}` : child.path;\n        params = child.params ? { ...params, ...child.params } : params;\n      }\n      return {\n        path,\n        params,\n      };\n    },\n\n    getActionForPathAndParams(\n      pathToResolve: string,\n      inputParams: ?NavigationParams\n    ): ?NavigationStackAction {\n      // If the path is empty (null or empty string)\n      // just return the initial route action\n      if (!pathToResolve) {\n        return NavigationActions.navigate({\n          routeName: initialRouteName,\n        });\n      }\n\n      const [pathNameToResolve, queryString] = pathToResolve.split('?');\n\n      // Attempt to match `pathNameToResolve` with a route in this router's\n      // routeConfigs\n      let matchedRouteName;\n      let pathMatch;\n      let pathMatchKeys;\n\n      // eslint-disable-next-line no-restricted-syntax\n      for (const [routeName, path] of Object.entries(paths)) {\n        /* $FlowFixMe */\n        const { re, keys } = path;\n        pathMatch = re.exec(pathNameToResolve);\n        if (pathMatch && pathMatch.length) {\n          pathMatchKeys = keys;\n          matchedRouteName = routeName;\n          break;\n        }\n      }\n\n      // We didn't match -- return null\n      if (!matchedRouteName) {\n        return null;\n      }\n\n      // Determine nested actions:\n      // If our matched route for this router is a child router,\n      // get the action for the path AFTER the matched path for this\n      // router\n      let nestedAction;\n      let nestedQueryString = queryString ? '?' + queryString : '';\n      if (childRouters[matchedRouteName]) {\n        nestedAction = childRouters[matchedRouteName].getActionForPathAndParams(\n          /* $FlowFixMe */\n          pathMatch.slice(pathMatchKeys.length).join('/') + nestedQueryString\n        );\n      }\n\n      // reduce the items of the query string. any query params may\n      // be overridden by path params\n      const queryParams =\n        inputParams ||\n        (queryString || '').split('&').reduce((result: *, item: string) => {\n          if (item !== '') {\n            const nextResult = result || {};\n            const [key, value] = item.split('=');\n            nextResult[key] = value;\n            return nextResult;\n          }\n          return result;\n        }, null);\n\n      // reduce the matched pieces of the path into the params\n      // of the route. `params` is null if there are no params.\n      /* $FlowFixMe */\n      const params = pathMatch\n        .slice(1)\n        .reduce((result: *, matchResult: *, i: number) => {\n          const key = pathMatchKeys[i];\n          if (key.asterisk || !key) {\n            return result;\n          }\n          const nextResult = result || {};\n          const paramName = key.name;\n          nextResult[paramName] = matchResult;\n          return nextResult;\n        }, queryParams);\n\n      return NavigationActions.navigate({\n        routeName: matchedRouteName,\n        ...(params ? { params } : {}),\n        ...(nestedAction ? { action: nestedAction } : {}),\n      });\n    },\n\n    getScreenOptions: createConfigGetter(\n      routeConfigs,\n      stackConfig.navigationOptions\n    ),\n\n    getScreenConfig: getScreenConfigDeprecated,\n  };\n};\n"]}]