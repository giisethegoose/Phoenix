["d69a2e5e29411c7d45312b4a02cf5f44d970c30c","59db5093b32b1b84bcd0cbfab8117e7f8b115d8d",["../operation/Operation","@firebase/util","./ChildChangeAccumulator","./Change","../snap/ChildrenNode","../snap/indexes/KeyIndex","../util/ImmutableTree","../util/Path","./CompleteChildSource"],[104,152,210,262,304,354,413,460,513],{"version":3,"sources":["/home/giise/candidtwo/node_modules/@firebase/database/dist/cjs/src/core/view/ViewProcessor.js"],"names":["Object","defineProperty","exports","value","Operation_1","require","util_1","ChildChangeAccumulator_1","Change_1","ChildrenNode_1","KeyIndex_1","ImmutableTree_1","Path_1","CompleteChildSource_1","ProcessorResult","viewCache","changes","ViewProcessor","filter_","prototype","assertIndexed","assert","getEventCache","getNode","isIndexed","getIndex","getServerCache","applyOperation","oldViewCache","operation","writesCache","completeCache","accumulator","ChildChangeAccumulator","newViewCache","filterServerNode","type","OperationType","OVERWRITE","overwrite","source","fromUser","applyUserOverwrite_","path","snap","fromServer","tagged","isFiltered","isEmpty","applyServerOverwrite_","MERGE","merge","applyUserMerge_","children","applyServerMerge_","ACK_USER_WRITE","ackUserWrite","revert","ackUserWrite_","affectedTree","revertUserWrite_","LISTEN_COMPLETE","listenComplete_","assertionError","getChanges","maybeAddValueEvent_","eventSnap","isFullyInitialized","isLeafOrEmpty","isLeafNode","oldCompleteSnap","getCompleteEventSnap","length","equals","getPriority","push","Change","valueChange","generateEventCacheAfterServerEvent_","changePath","oldEventSnap","shadowingWrite","newEventCache","serverNode","serverCache","getCompleteServerSnap","completeChildren","ChildrenNode","EMPTY_NODE","completeEventChildren","calcCompleteEventChildren","updateFullNode","completeNode","calcCompleteEventCache","childKey","getFront","getLength","oldEventNode","updatedPriority","calcEventCacheAfterServerOverwrite","updatePriority","childChangePath","popFront","newEventChild","isCompleteForChild","eventChildUpdate","getImmediateChild","updateChild","calcCompleteChild","updateEventSnap","filtersNodes","changedSnap","oldServerSnap","newServerCache","serverFilter","getIndexedFilter","newServerNode","isCompleteForPath","childNode","newChildNode","NO_COMPLETE_CHILD_SOURCE","updateServerSnap","WriteTreeCompleteChildSource","oldChild","newChild","getCompleteChild","getBack","getChild","parent","newEventSnap","cacheHasChild_","changedChildren","_this","curViewCache","foreach","relativePath","writePath","child","applyMerge_","node","viewMergeTree","ImmutableTree","Empty","setTree","inorderTraversal","childTree","hasChild","serverChild","Path","childMergeTree","isUnknownDeepMerge","ackPath","changedChildren_1","forEachChild","KEY_INDEX","name","set","changedChildren_2","mergePath","serverCachePath","oldServerNode","completeServerCache","complete","oldEventCache","newNode","serverChildren"],"mappings":"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","sourcesContent":["\"use strict\";\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Operation_1 = require(\"../operation/Operation\");\nvar util_1 = require(\"@firebase/util\");\nvar ChildChangeAccumulator_1 = require(\"./ChildChangeAccumulator\");\nvar Change_1 = require(\"./Change\");\nvar ChildrenNode_1 = require(\"../snap/ChildrenNode\");\nvar KeyIndex_1 = require(\"../snap/indexes/KeyIndex\");\nvar ImmutableTree_1 = require(\"../util/ImmutableTree\");\nvar Path_1 = require(\"../util/Path\");\nvar CompleteChildSource_1 = require(\"./CompleteChildSource\");\n/**\n * @constructor\n * @struct\n */\nvar ProcessorResult = /** @class */ (function () {\n    /**\n     * @param {!ViewCache} viewCache\n     * @param {!Array.<!Change>} changes\n     */\n    function ProcessorResult(viewCache, changes) {\n        this.viewCache = viewCache;\n        this.changes = changes;\n    }\n    return ProcessorResult;\n}());\nexports.ProcessorResult = ProcessorResult;\n/**\n * @constructor\n */\nvar ViewProcessor = /** @class */ (function () {\n    /**\n     * @param {!NodeFilter} filter_\n     */\n    function ViewProcessor(filter_) {\n        this.filter_ = filter_;\n    }\n    /**\n     * @param {!ViewCache} viewCache\n     */\n    ViewProcessor.prototype.assertIndexed = function (viewCache) {\n        util_1.assert(viewCache\n            .getEventCache()\n            .getNode()\n            .isIndexed(this.filter_.getIndex()), 'Event snap not indexed');\n        util_1.assert(viewCache\n            .getServerCache()\n            .getNode()\n            .isIndexed(this.filter_.getIndex()), 'Server snap not indexed');\n    };\n    /**\n     * @param {!ViewCache} oldViewCache\n     * @param {!Operation} operation\n     * @param {!WriteTreeRef} writesCache\n     * @param {?Node} completeCache\n     * @return {!ProcessorResult}\n     */\n    ViewProcessor.prototype.applyOperation = function (oldViewCache, operation, writesCache, completeCache) {\n        var accumulator = new ChildChangeAccumulator_1.ChildChangeAccumulator();\n        var newViewCache, filterServerNode;\n        if (operation.type === Operation_1.OperationType.OVERWRITE) {\n            var overwrite = operation;\n            if (overwrite.source.fromUser) {\n                newViewCache = this.applyUserOverwrite_(oldViewCache, overwrite.path, overwrite.snap, writesCache, completeCache, accumulator);\n            }\n            else {\n                util_1.assert(overwrite.source.fromServer, 'Unknown source.');\n                // We filter the node if it's a tagged update or the node has been previously filtered  and the\n                // update is not at the root in which case it is ok (and necessary) to mark the node unfiltered\n                // again\n                filterServerNode =\n                    overwrite.source.tagged ||\n                        (oldViewCache.getServerCache().isFiltered() &&\n                            !overwrite.path.isEmpty());\n                newViewCache = this.applyServerOverwrite_(oldViewCache, overwrite.path, overwrite.snap, writesCache, completeCache, filterServerNode, accumulator);\n            }\n        }\n        else if (operation.type === Operation_1.OperationType.MERGE) {\n            var merge = operation;\n            if (merge.source.fromUser) {\n                newViewCache = this.applyUserMerge_(oldViewCache, merge.path, merge.children, writesCache, completeCache, accumulator);\n            }\n            else {\n                util_1.assert(merge.source.fromServer, 'Unknown source.');\n                // We filter the node if it's a tagged update or the node has been previously filtered\n                filterServerNode =\n                    merge.source.tagged || oldViewCache.getServerCache().isFiltered();\n                newViewCache = this.applyServerMerge_(oldViewCache, merge.path, merge.children, writesCache, completeCache, filterServerNode, accumulator);\n            }\n        }\n        else if (operation.type === Operation_1.OperationType.ACK_USER_WRITE) {\n            var ackUserWrite = operation;\n            if (!ackUserWrite.revert) {\n                newViewCache = this.ackUserWrite_(oldViewCache, ackUserWrite.path, ackUserWrite.affectedTree, writesCache, completeCache, accumulator);\n            }\n            else {\n                newViewCache = this.revertUserWrite_(oldViewCache, ackUserWrite.path, writesCache, completeCache, accumulator);\n            }\n        }\n        else if (operation.type === Operation_1.OperationType.LISTEN_COMPLETE) {\n            newViewCache = this.listenComplete_(oldViewCache, operation.path, writesCache, accumulator);\n        }\n        else {\n            throw util_1.assertionError('Unknown operation type: ' + operation.type);\n        }\n        var changes = accumulator.getChanges();\n        ViewProcessor.maybeAddValueEvent_(oldViewCache, newViewCache, changes);\n        return new ProcessorResult(newViewCache, changes);\n    };\n    /**\n     * @param {!ViewCache} oldViewCache\n     * @param {!ViewCache} newViewCache\n     * @param {!Array.<!Change>} accumulator\n     * @private\n     */\n    ViewProcessor.maybeAddValueEvent_ = function (oldViewCache, newViewCache, accumulator) {\n        var eventSnap = newViewCache.getEventCache();\n        if (eventSnap.isFullyInitialized()) {\n            var isLeafOrEmpty = eventSnap.getNode().isLeafNode() || eventSnap.getNode().isEmpty();\n            var oldCompleteSnap = oldViewCache.getCompleteEventSnap();\n            if (accumulator.length > 0 ||\n                !oldViewCache.getEventCache().isFullyInitialized() ||\n                (isLeafOrEmpty &&\n                    !eventSnap\n                        .getNode()\n                        .equals(/** @type {!Node} */ (oldCompleteSnap))) ||\n                !eventSnap\n                    .getNode()\n                    .getPriority()\n                    .equals(oldCompleteSnap.getPriority())) {\n                accumulator.push(Change_1.Change.valueChange(\n                /** @type {!Node} */ newViewCache.getCompleteEventSnap()));\n            }\n        }\n    };\n    /**\n     * @param {!ViewCache} viewCache\n     * @param {!Path} changePath\n     * @param {!WriteTreeRef} writesCache\n     * @param {!CompleteChildSource} source\n     * @param {!ChildChangeAccumulator} accumulator\n     * @return {!ViewCache}\n     * @private\n     */\n    ViewProcessor.prototype.generateEventCacheAfterServerEvent_ = function (viewCache, changePath, writesCache, source, accumulator) {\n        var oldEventSnap = viewCache.getEventCache();\n        if (writesCache.shadowingWrite(changePath) != null) {\n            // we have a shadowing write, ignore changes\n            return viewCache;\n        }\n        else {\n            var newEventCache = void 0, serverNode = void 0;\n            if (changePath.isEmpty()) {\n                // TODO: figure out how this plays with \"sliding ack windows\"\n                util_1.assert(viewCache.getServerCache().isFullyInitialized(), 'If change path is empty, we must have complete server data');\n                if (viewCache.getServerCache().isFiltered()) {\n                    // We need to special case this, because we need to only apply writes to complete children, or\n                    // we might end up raising events for incomplete children. If the server data is filtered deep\n                    // writes cannot be guaranteed to be complete\n                    var serverCache = viewCache.getCompleteServerSnap();\n                    var completeChildren = serverCache instanceof ChildrenNode_1.ChildrenNode\n                        ? serverCache\n                        : ChildrenNode_1.ChildrenNode.EMPTY_NODE;\n                    var completeEventChildren = writesCache.calcCompleteEventChildren(completeChildren);\n                    newEventCache = this.filter_.updateFullNode(viewCache.getEventCache().getNode(), completeEventChildren, accumulator);\n                }\n                else {\n                    var completeNode = writesCache.calcCompleteEventCache(viewCache.getCompleteServerSnap());\n                    newEventCache = this.filter_.updateFullNode(viewCache.getEventCache().getNode(), completeNode, accumulator);\n                }\n            }\n            else {\n                var childKey = changePath.getFront();\n                if (childKey == '.priority') {\n                    util_1.assert(changePath.getLength() == 1, \"Can't have a priority with additional path components\");\n                    var oldEventNode = oldEventSnap.getNode();\n                    serverNode = viewCache.getServerCache().getNode();\n                    // we might have overwrites for this priority\n                    var updatedPriority = writesCache.calcEventCacheAfterServerOverwrite(changePath, oldEventNode, serverNode);\n                    if (updatedPriority != null) {\n                        newEventCache = this.filter_.updatePriority(oldEventNode, updatedPriority);\n                    }\n                    else {\n                        // priority didn't change, keep old node\n                        newEventCache = oldEventSnap.getNode();\n                    }\n                }\n                else {\n                    var childChangePath = changePath.popFront();\n                    // update child\n                    var newEventChild = void 0;\n                    if (oldEventSnap.isCompleteForChild(childKey)) {\n                        serverNode = viewCache.getServerCache().getNode();\n                        var eventChildUpdate = writesCache.calcEventCacheAfterServerOverwrite(changePath, oldEventSnap.getNode(), serverNode);\n                        if (eventChildUpdate != null) {\n                            newEventChild = oldEventSnap\n                                .getNode()\n                                .getImmediateChild(childKey)\n                                .updateChild(childChangePath, eventChildUpdate);\n                        }\n                        else {\n                            // Nothing changed, just keep the old child\n                            newEventChild = oldEventSnap\n                                .getNode()\n                                .getImmediateChild(childKey);\n                        }\n                    }\n                    else {\n                        newEventChild = writesCache.calcCompleteChild(childKey, viewCache.getServerCache());\n                    }\n                    if (newEventChild != null) {\n                        newEventCache = this.filter_.updateChild(oldEventSnap.getNode(), childKey, newEventChild, childChangePath, source, accumulator);\n                    }\n                    else {\n                        // no complete child available or no change\n                        newEventCache = oldEventSnap.getNode();\n                    }\n                }\n            }\n            return viewCache.updateEventSnap(newEventCache, oldEventSnap.isFullyInitialized() || changePath.isEmpty(), this.filter_.filtersNodes());\n        }\n    };\n    /**\n     * @param {!ViewCache} oldViewCache\n     * @param {!Path} changePath\n     * @param {!Node} changedSnap\n     * @param {!WriteTreeRef} writesCache\n     * @param {?Node} completeCache\n     * @param {boolean} filterServerNode\n     * @param {!ChildChangeAccumulator} accumulator\n     * @return {!ViewCache}\n     * @private\n     */\n    ViewProcessor.prototype.applyServerOverwrite_ = function (oldViewCache, changePath, changedSnap, writesCache, completeCache, filterServerNode, accumulator) {\n        var oldServerSnap = oldViewCache.getServerCache();\n        var newServerCache;\n        var serverFilter = filterServerNode\n            ? this.filter_\n            : this.filter_.getIndexedFilter();\n        if (changePath.isEmpty()) {\n            newServerCache = serverFilter.updateFullNode(oldServerSnap.getNode(), changedSnap, null);\n        }\n        else if (serverFilter.filtersNodes() && !oldServerSnap.isFiltered()) {\n            // we want to filter the server node, but we didn't filter the server node yet, so simulate a full update\n            var newServerNode = oldServerSnap\n                .getNode()\n                .updateChild(changePath, changedSnap);\n            newServerCache = serverFilter.updateFullNode(oldServerSnap.getNode(), newServerNode, null);\n        }\n        else {\n            var childKey = changePath.getFront();\n            if (!oldServerSnap.isCompleteForPath(changePath) &&\n                changePath.getLength() > 1) {\n                // We don't update incomplete nodes with updates intended for other listeners\n                return oldViewCache;\n            }\n            var childChangePath = changePath.popFront();\n            var childNode = oldServerSnap.getNode().getImmediateChild(childKey);\n            var newChildNode = childNode.updateChild(childChangePath, changedSnap);\n            if (childKey == '.priority') {\n                newServerCache = serverFilter.updatePriority(oldServerSnap.getNode(), newChildNode);\n            }\n            else {\n                newServerCache = serverFilter.updateChild(oldServerSnap.getNode(), childKey, newChildNode, childChangePath, CompleteChildSource_1.NO_COMPLETE_CHILD_SOURCE, null);\n            }\n        }\n        var newViewCache = oldViewCache.updateServerSnap(newServerCache, oldServerSnap.isFullyInitialized() || changePath.isEmpty(), serverFilter.filtersNodes());\n        var source = new CompleteChildSource_1.WriteTreeCompleteChildSource(writesCache, newViewCache, completeCache);\n        return this.generateEventCacheAfterServerEvent_(newViewCache, changePath, writesCache, source, accumulator);\n    };\n    /**\n     * @param {!ViewCache} oldViewCache\n     * @param {!Path} changePath\n     * @param {!Node} changedSnap\n     * @param {!WriteTreeRef} writesCache\n     * @param {?Node} completeCache\n     * @param {!ChildChangeAccumulator} accumulator\n     * @return {!ViewCache}\n     * @private\n     */\n    ViewProcessor.prototype.applyUserOverwrite_ = function (oldViewCache, changePath, changedSnap, writesCache, completeCache, accumulator) {\n        var oldEventSnap = oldViewCache.getEventCache();\n        var newViewCache, newEventCache;\n        var source = new CompleteChildSource_1.WriteTreeCompleteChildSource(writesCache, oldViewCache, completeCache);\n        if (changePath.isEmpty()) {\n            newEventCache = this.filter_.updateFullNode(oldViewCache.getEventCache().getNode(), changedSnap, accumulator);\n            newViewCache = oldViewCache.updateEventSnap(newEventCache, true, this.filter_.filtersNodes());\n        }\n        else {\n            var childKey = changePath.getFront();\n            if (childKey === '.priority') {\n                newEventCache = this.filter_.updatePriority(oldViewCache.getEventCache().getNode(), changedSnap);\n                newViewCache = oldViewCache.updateEventSnap(newEventCache, oldEventSnap.isFullyInitialized(), oldEventSnap.isFiltered());\n            }\n            else {\n                var childChangePath = changePath.popFront();\n                var oldChild = oldEventSnap.getNode().getImmediateChild(childKey);\n                var newChild = void 0;\n                if (childChangePath.isEmpty()) {\n                    // Child overwrite, we can replace the child\n                    newChild = changedSnap;\n                }\n                else {\n                    var childNode = source.getCompleteChild(childKey);\n                    if (childNode != null) {\n                        if (childChangePath.getBack() === '.priority' &&\n                            childNode.getChild(childChangePath.parent()).isEmpty()) {\n                            // This is a priority update on an empty node. If this node exists on the server, the\n                            // server will send down the priority in the update, so ignore for now\n                            newChild = childNode;\n                        }\n                        else {\n                            newChild = childNode.updateChild(childChangePath, changedSnap);\n                        }\n                    }\n                    else {\n                        // There is no complete child node available\n                        newChild = ChildrenNode_1.ChildrenNode.EMPTY_NODE;\n                    }\n                }\n                if (!oldChild.equals(newChild)) {\n                    var newEventSnap = this.filter_.updateChild(oldEventSnap.getNode(), childKey, newChild, childChangePath, source, accumulator);\n                    newViewCache = oldViewCache.updateEventSnap(newEventSnap, oldEventSnap.isFullyInitialized(), this.filter_.filtersNodes());\n                }\n                else {\n                    newViewCache = oldViewCache;\n                }\n            }\n        }\n        return newViewCache;\n    };\n    /**\n     * @param {!ViewCache} viewCache\n     * @param {string} childKey\n     * @return {boolean}\n     * @private\n     */\n    ViewProcessor.cacheHasChild_ = function (viewCache, childKey) {\n        return viewCache.getEventCache().isCompleteForChild(childKey);\n    };\n    /**\n     * @param {!ViewCache} viewCache\n     * @param {!Path} path\n     * @param {ImmutableTree.<!Node>} changedChildren\n     * @param {!WriteTreeRef} writesCache\n     * @param {?Node} serverCache\n     * @param {!ChildChangeAccumulator} accumulator\n     * @return {!ViewCache}\n     * @private\n     */\n    ViewProcessor.prototype.applyUserMerge_ = function (viewCache, path, changedChildren, writesCache, serverCache, accumulator) {\n        var _this = this;\n        // HACK: In the case of a limit query, there may be some changes that bump things out of the\n        // window leaving room for new items.  It's important we process these changes first, so we\n        // iterate the changes twice, first processing any that affect items currently in view.\n        // TODO: I consider an item \"in view\" if cacheHasChild is true, which checks both the server\n        // and event snap.  I'm not sure if this will result in edge cases when a child is in one but\n        // not the other.\n        var curViewCache = viewCache;\n        changedChildren.foreach(function (relativePath, childNode) {\n            var writePath = path.child(relativePath);\n            if (ViewProcessor.cacheHasChild_(viewCache, writePath.getFront())) {\n                curViewCache = _this.applyUserOverwrite_(curViewCache, writePath, childNode, writesCache, serverCache, accumulator);\n            }\n        });\n        changedChildren.foreach(function (relativePath, childNode) {\n            var writePath = path.child(relativePath);\n            if (!ViewProcessor.cacheHasChild_(viewCache, writePath.getFront())) {\n                curViewCache = _this.applyUserOverwrite_(curViewCache, writePath, childNode, writesCache, serverCache, accumulator);\n            }\n        });\n        return curViewCache;\n    };\n    /**\n     * @param {!Node} node\n     * @param {ImmutableTree.<!Node>} merge\n     * @return {!Node}\n     * @private\n     */\n    ViewProcessor.prototype.applyMerge_ = function (node, merge) {\n        merge.foreach(function (relativePath, childNode) {\n            node = node.updateChild(relativePath, childNode);\n        });\n        return node;\n    };\n    /**\n     * @param {!ViewCache} viewCache\n     * @param {!Path} path\n     * @param {!ImmutableTree.<!Node>} changedChildren\n     * @param {!WriteTreeRef} writesCache\n     * @param {?Node} serverCache\n     * @param {boolean} filterServerNode\n     * @param {!ChildChangeAccumulator} accumulator\n     * @return {!ViewCache}\n     * @private\n     */\n    ViewProcessor.prototype.applyServerMerge_ = function (viewCache, path, changedChildren, writesCache, serverCache, filterServerNode, accumulator) {\n        var _this = this;\n        // If we don't have a cache yet, this merge was intended for a previously listen in the same location. Ignore it and\n        // wait for the complete data update coming soon.\n        if (viewCache\n            .getServerCache()\n            .getNode()\n            .isEmpty() &&\n            !viewCache.getServerCache().isFullyInitialized()) {\n            return viewCache;\n        }\n        // HACK: In the case of a limit query, there may be some changes that bump things out of the\n        // window leaving room for new items.  It's important we process these changes first, so we\n        // iterate the changes twice, first processing any that affect items currently in view.\n        // TODO: I consider an item \"in view\" if cacheHasChild is true, which checks both the server\n        // and event snap.  I'm not sure if this will result in edge cases when a child is in one but\n        // not the other.\n        var curViewCache = viewCache;\n        var viewMergeTree;\n        if (path.isEmpty()) {\n            viewMergeTree = changedChildren;\n        }\n        else {\n            viewMergeTree = ImmutableTree_1.ImmutableTree.Empty.setTree(path, changedChildren);\n        }\n        var serverNode = viewCache.getServerCache().getNode();\n        viewMergeTree.children.inorderTraversal(function (childKey, childTree) {\n            if (serverNode.hasChild(childKey)) {\n                var serverChild = viewCache\n                    .getServerCache()\n                    .getNode()\n                    .getImmediateChild(childKey);\n                var newChild = _this.applyMerge_(serverChild, childTree);\n                curViewCache = _this.applyServerOverwrite_(curViewCache, new Path_1.Path(childKey), newChild, writesCache, serverCache, filterServerNode, accumulator);\n            }\n        });\n        viewMergeTree.children.inorderTraversal(function (childKey, childMergeTree) {\n            var isUnknownDeepMerge = !viewCache.getServerCache().isCompleteForChild(childKey) &&\n                childMergeTree.value == null;\n            if (!serverNode.hasChild(childKey) && !isUnknownDeepMerge) {\n                var serverChild = viewCache\n                    .getServerCache()\n                    .getNode()\n                    .getImmediateChild(childKey);\n                var newChild = _this.applyMerge_(serverChild, childMergeTree);\n                curViewCache = _this.applyServerOverwrite_(curViewCache, new Path_1.Path(childKey), newChild, writesCache, serverCache, filterServerNode, accumulator);\n            }\n        });\n        return curViewCache;\n    };\n    /**\n     * @param {!ViewCache} viewCache\n     * @param {!Path} ackPath\n     * @param {!ImmutableTree<!boolean>} affectedTree\n     * @param {!WriteTreeRef} writesCache\n     * @param {?Node} completeCache\n     * @param {!ChildChangeAccumulator} accumulator\n     * @return {!ViewCache}\n     * @private\n     */\n    ViewProcessor.prototype.ackUserWrite_ = function (viewCache, ackPath, affectedTree, writesCache, completeCache, accumulator) {\n        if (writesCache.shadowingWrite(ackPath) != null) {\n            return viewCache;\n        }\n        // Only filter server node if it is currently filtered\n        var filterServerNode = viewCache.getServerCache().isFiltered();\n        // Essentially we'll just get our existing server cache for the affected paths and re-apply it as a server update\n        // now that it won't be shadowed.\n        var serverCache = viewCache.getServerCache();\n        if (affectedTree.value != null) {\n            // This is an overwrite.\n            if ((ackPath.isEmpty() && serverCache.isFullyInitialized()) ||\n                serverCache.isCompleteForPath(ackPath)) {\n                return this.applyServerOverwrite_(viewCache, ackPath, serverCache.getNode().getChild(ackPath), writesCache, completeCache, filterServerNode, accumulator);\n            }\n            else if (ackPath.isEmpty()) {\n                // This is a goofy edge case where we are acking data at this location but don't have full data.  We\n                // should just re-apply whatever we have in our cache as a merge.\n                var changedChildren_1 = ImmutableTree_1.ImmutableTree.Empty;\n                serverCache.getNode().forEachChild(KeyIndex_1.KEY_INDEX, function (name, node) {\n                    changedChildren_1 = changedChildren_1.set(new Path_1.Path(name), node);\n                });\n                return this.applyServerMerge_(viewCache, ackPath, changedChildren_1, writesCache, completeCache, filterServerNode, accumulator);\n            }\n            else {\n                return viewCache;\n            }\n        }\n        else {\n            // This is a merge.\n            var changedChildren_2 = ImmutableTree_1.ImmutableTree.Empty;\n            affectedTree.foreach(function (mergePath, value) {\n                var serverCachePath = ackPath.child(mergePath);\n                if (serverCache.isCompleteForPath(serverCachePath)) {\n                    changedChildren_2 = changedChildren_2.set(mergePath, serverCache.getNode().getChild(serverCachePath));\n                }\n            });\n            return this.applyServerMerge_(viewCache, ackPath, changedChildren_2, writesCache, completeCache, filterServerNode, accumulator);\n        }\n    };\n    /**\n     * @param {!ViewCache} viewCache\n     * @param {!Path} path\n     * @param {!WriteTreeRef} writesCache\n     * @param {!ChildChangeAccumulator} accumulator\n     * @return {!ViewCache}\n     * @private\n     */\n    ViewProcessor.prototype.listenComplete_ = function (viewCache, path, writesCache, accumulator) {\n        var oldServerNode = viewCache.getServerCache();\n        var newViewCache = viewCache.updateServerSnap(oldServerNode.getNode(), oldServerNode.isFullyInitialized() || path.isEmpty(), oldServerNode.isFiltered());\n        return this.generateEventCacheAfterServerEvent_(newViewCache, path, writesCache, CompleteChildSource_1.NO_COMPLETE_CHILD_SOURCE, accumulator);\n    };\n    /**\n     * @param {!ViewCache} viewCache\n     * @param {!Path} path\n     * @param {!WriteTreeRef} writesCache\n     * @param {?Node} completeServerCache\n     * @param {!ChildChangeAccumulator} accumulator\n     * @return {!ViewCache}\n     * @private\n     */\n    ViewProcessor.prototype.revertUserWrite_ = function (viewCache, path, writesCache, completeServerCache, accumulator) {\n        var complete;\n        if (writesCache.shadowingWrite(path) != null) {\n            return viewCache;\n        }\n        else {\n            var source = new CompleteChildSource_1.WriteTreeCompleteChildSource(writesCache, viewCache, completeServerCache);\n            var oldEventCache = viewCache.getEventCache().getNode();\n            var newEventCache = void 0;\n            if (path.isEmpty() || path.getFront() === '.priority') {\n                var newNode = void 0;\n                if (viewCache.getServerCache().isFullyInitialized()) {\n                    newNode = writesCache.calcCompleteEventCache(viewCache.getCompleteServerSnap());\n                }\n                else {\n                    var serverChildren = viewCache.getServerCache().getNode();\n                    util_1.assert(serverChildren instanceof ChildrenNode_1.ChildrenNode, 'serverChildren would be complete if leaf node');\n                    newNode = writesCache.calcCompleteEventChildren(serverChildren);\n                }\n                newNode = newNode;\n                newEventCache = this.filter_.updateFullNode(oldEventCache, newNode, accumulator);\n            }\n            else {\n                var childKey = path.getFront();\n                var newChild = writesCache.calcCompleteChild(childKey, viewCache.getServerCache());\n                if (newChild == null &&\n                    viewCache.getServerCache().isCompleteForChild(childKey)) {\n                    newChild = oldEventCache.getImmediateChild(childKey);\n                }\n                if (newChild != null) {\n                    newEventCache = this.filter_.updateChild(oldEventCache, childKey, newChild, path.popFront(), source, accumulator);\n                }\n                else if (viewCache\n                    .getEventCache()\n                    .getNode()\n                    .hasChild(childKey)) {\n                    // No complete child available, delete the existing one, if any\n                    newEventCache = this.filter_.updateChild(oldEventCache, childKey, ChildrenNode_1.ChildrenNode.EMPTY_NODE, path.popFront(), source, accumulator);\n                }\n                else {\n                    newEventCache = oldEventCache;\n                }\n                if (newEventCache.isEmpty() &&\n                    viewCache.getServerCache().isFullyInitialized()) {\n                    // We might have reverted all child writes. Maybe the old event was a leaf node\n                    complete = writesCache.calcCompleteEventCache(viewCache.getCompleteServerSnap());\n                    if (complete.isLeafNode()) {\n                        newEventCache = this.filter_.updateFullNode(newEventCache, complete, accumulator);\n                    }\n                }\n            }\n            complete =\n                viewCache.getServerCache().isFullyInitialized() ||\n                    writesCache.shadowingWrite(Path_1.Path.Empty) != null;\n            return viewCache.updateEventSnap(newEventCache, complete, this.filter_.filtersNodes());\n        }\n    };\n    return ViewProcessor;\n}());\nexports.ViewProcessor = ViewProcessor;\n\n//# sourceMappingURL=ViewProcessor.js.map\n"]}]