["50d80e83ed4f68fb951d2de4651e919954bca41b","c9d076fdd5e9a8bfd0444250d468acfa3041bae0",[],[],{"version":3,"sources":["/home/giise/candidtwo/node_modules/react-proxy/modules/deleteUnknownAutoBindMethods.js"],"names":["Object","defineProperty","exports","value","default","deleteUnknownAutoBindMethods","shouldDeleteClassicInstanceMethod","component","name","__reactAutoBindMap","hasOwnProperty","__reactAutoBindPairs","indexOf","__reactBoundArguments","shouldDeleteModernInstanceMethod","prototype","constructor","prototypeDescriptor","getOwnPropertyDescriptor","get","length","shouldDeleteInstanceMethod","descriptor","names","getOwnPropertyNames","forEach"],"mappings":"AAAA;;AAEAA,OAAOC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,SAAO;AADoC,CAA7C;AAGAD,QAAQE,OAAR,GAAkBC,4BAAlB;AACA,SAASC,iCAAT,CAA2CC,SAA3C,EAAsDC,IAAtD,EAA4D;AAC1D,MAAID,UAAUE,kBAAV,IAAgCF,UAAUE,kBAAV,CAA6BC,cAA7B,CAA4CF,IAA5C,CAApC,EAAuF;AAErF,WAAO,KAAP;AACD;;AAED,MAAID,UAAUI,oBAAV,IAAkCJ,UAAUI,oBAAV,CAA+BC,OAA/B,CAAuCJ,IAAvC,KAAgD,CAAtF,EAAyF;AAEvF,WAAO,KAAP;AACD;;AAED,MAAID,UAAUC,IAAV,EAAgBK,qBAAhB,KAA0C,IAA9C,EAAoD;AAElD,WAAO,KAAP;AACD;;AAID,SAAO,IAAP;AACD;;AAED,SAASC,gCAAT,CAA0CP,SAA1C,EAAqDC,IAArD,EAA2D;AACzD,MAAIO,YAAYR,UAAUS,WAAV,CAAsBD,SAAtC;;AAEA,MAAIE,sBAAsBjB,OAAOkB,wBAAP,CAAgCH,SAAhC,EAA2CP,IAA3C,CAA1B;;AAEA,MAAI,CAACS,mBAAD,IAAwB,CAACA,oBAAoBE,GAAjD,EAAsD;AAEpD,WAAO,KAAP;AACD;;AAED,MAAIF,oBAAoBE,GAApB,GAA0BC,MAA1B,KAAqCb,UAAUC,IAAV,EAAgBY,MAAzD,EAAiE;AAE/D,WAAO,KAAP;AACD;;AAID,SAAO,IAAP;AACD;;AAED,SAASC,0BAAT,CAAoCd,SAApC,EAA+CC,IAA/C,EAAqD;AACnD,MAAIc,aAAatB,OAAOkB,wBAAP,CAAgCX,SAAhC,EAA2CC,IAA3C,CAAjB;AACA,MAAI,OAAOc,WAAWnB,KAAlB,KAA4B,UAAhC,EAA4C;AAE1C;AACD;;AAED,MAAII,UAAUE,kBAAV,IAAgCF,UAAUI,oBAA9C,EAAoE;AAElE,WAAOL,kCAAkCC,SAAlC,EAA6CC,IAA7C,CAAP;AACD,GAHD,MAGO;AAEL,WAAOM,iCAAiCP,SAAjC,EAA4CC,IAA5C,CAAP;AACD;AACF;;AAaD,SAASH,4BAAT,CAAsCE,SAAtC,EAAiD;AAC/C,MAAIgB,QAAQvB,OAAOwB,mBAAP,CAA2BjB,SAA3B,CAAZ;;AAEAgB,QAAME,OAAN,CAAc,UAAUjB,IAAV,EAAgB;AAC5B,QAAIa,2BAA2Bd,SAA3B,EAAsCC,IAAtC,CAAJ,EAAiD;AAC/C,aAAOD,UAAUC,IAAV,CAAP;AACD;AACF,GAJD;AAKD","sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = deleteUnknownAutoBindMethods;\nfunction shouldDeleteClassicInstanceMethod(component, name) {\n  if (component.__reactAutoBindMap && component.__reactAutoBindMap.hasOwnProperty(name)) {\n    // It's a known autobound function, keep it\n    return false;\n  }\n\n  if (component.__reactAutoBindPairs && component.__reactAutoBindPairs.indexOf(name) >= 0) {\n    // It's a known autobound function, keep it\n    return false;\n  }\n\n  if (component[name].__reactBoundArguments !== null) {\n    // It's a function bound to specific args, keep it\n    return false;\n  }\n\n  // It's a cached bound method for a function\n  // that was deleted by user, so we delete it from component.\n  return true;\n}\n\nfunction shouldDeleteModernInstanceMethod(component, name) {\n  var prototype = component.constructor.prototype;\n\n  var prototypeDescriptor = Object.getOwnPropertyDescriptor(prototype, name);\n\n  if (!prototypeDescriptor || !prototypeDescriptor.get) {\n    // This is definitely not an autobinding getter\n    return false;\n  }\n\n  if (prototypeDescriptor.get().length !== component[name].length) {\n    // The length doesn't match, bail out\n    return false;\n  }\n\n  // This seems like a method bound using an autobinding getter on the prototype\n  // Hopefully we won't run into too many false positives.\n  return true;\n}\n\nfunction shouldDeleteInstanceMethod(component, name) {\n  var descriptor = Object.getOwnPropertyDescriptor(component, name);\n  if (typeof descriptor.value !== 'function') {\n    // Not a function, or something fancy: bail out\n    return;\n  }\n\n  if (component.__reactAutoBindMap || component.__reactAutoBindPairs) {\n    // Classic\n    return shouldDeleteClassicInstanceMethod(component, name);\n  } else {\n    // Modern\n    return shouldDeleteModernInstanceMethod(component, name);\n  }\n}\n\n/**\n * Deletes autobound methods from the instance.\n *\n * For classic React classes, we only delete the methods that no longer exist in map.\n * This means the user actually deleted them in code.\n *\n * For modern classes, we delete methods that exist on prototype with the same length,\n * and which have getters on prototype, but are normal values on the instance.\n * This is usually an indication that an autobinding decorator is being used,\n * and the getter will re-generate the memoized handler on next access.\n */\nfunction deleteUnknownAutoBindMethods(component) {\n  var names = Object.getOwnPropertyNames(component);\n\n  names.forEach(function (name) {\n    if (shouldDeleteInstanceMethod(component, name)) {\n      delete component[name];\n    }\n  });\n}"]}]