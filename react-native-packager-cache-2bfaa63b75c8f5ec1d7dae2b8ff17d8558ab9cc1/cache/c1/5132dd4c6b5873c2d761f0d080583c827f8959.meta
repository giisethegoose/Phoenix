["350fca92040ac5f43c516d00b8b0d730008d4e9e","5f0c3d08e829bd0ba6bb5a6598552631569d371a",["../utils/invariant","./getScreenForRouteName","./createConfigGetter","../NavigationActions","./validateRouteConfigMap","./getScreenConfigDeprecated"],[91,219,373,517,664,828],{"version":3,"sources":["/home/giise/candidtwo/node_modules/react-navigation/src/routers/TabRouter.js"],"names":["routeConfigs","config","order","Object","keys","paths","initialRouteName","initialRouteIndex","indexOf","backBehavior","shouldBackNavigateToInitialRoute","tabRouters","forEach","routeName","routeConfig","path","screen","router","Error","map","n","join","getStateForAction","action","inputState","state","routes","tabRouter","childAction","init","params","key","index","type","INIT","route","activeTabLastState","activeTabRouter","activeTabState","activeTabIndex","isBackEligible","BACK","didNavigate","NAVIGATE","navigateAction","find","tabId","i","childState","newChildState","SET_PARAMS","lastRoute","tabState","getComponentForState","childRouter","getComponentForRouteName","getPathAndParamsForState","subPath","stateRoute","child","getActionForPathAndParams","parts","split","pathToTest","navigate","slice","getScreenOptions","navigationOptions","getScreenConfig"],"mappings":"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","sourcesContent":["/* @flow */\n\nimport invariant from '../utils/invariant';\nimport getScreenForRouteName from './getScreenForRouteName';\nimport createConfigGetter from './createConfigGetter';\n\nimport NavigationActions from '../NavigationActions';\nimport validateRouteConfigMap from './validateRouteConfigMap';\nimport getScreenConfigDeprecated from './getScreenConfigDeprecated';\n\nimport type {\n  NavigationComponent,\n  NavigationState,\n  NavigationRouteConfigMap,\n  NavigationParams,\n  NavigationRouter,\n  NavigationRoute,\n  NavigationNavigateAction,\n  NavigationTabRouterConfig,\n  NavigationTabAction,\n  NavigationStateRoute,\n} from '../TypeDefinition';\n\nexport default (\n  routeConfigs: NavigationRouteConfigMap,\n  config: NavigationTabRouterConfig = {}\n): NavigationRouter<NavigationState, NavigationTabAction, *> => {\n  // Fail fast on invalid route definitions\n  validateRouteConfigMap(routeConfigs);\n\n  const order = config.order || Object.keys(routeConfigs);\n  const paths = config.paths || {};\n  const initialRouteName = config.initialRouteName || order[0];\n  const initialRouteIndex = order.indexOf(initialRouteName);\n  const backBehavior = config.backBehavior || 'initialRoute';\n  const shouldBackNavigateToInitialRoute = backBehavior === 'initialRoute';\n  const tabRouters = {};\n  order.forEach((routeName: string) => {\n    const routeConfig = routeConfigs[routeName];\n    paths[routeName] =\n      typeof routeConfig.path === 'string' ? routeConfig.path : routeName;\n    tabRouters[routeName] = null;\n    if (routeConfig.screen && routeConfig.screen.router) {\n      tabRouters[routeName] = routeConfig.screen.router;\n    }\n  });\n  if (initialRouteIndex === -1) {\n    throw new Error(\n      `Invalid initialRouteName '${initialRouteName}' for TabRouter. ` +\n        `Should be one of ${order.map((n: *) => `\"${n}\"`).join(', ')}`\n    );\n  }\n  return {\n    getStateForAction(\n      action: NavigationTabAction,\n      inputState?: ?NavigationState\n    ): ?NavigationState {\n      // Establish a default state\n      let state = inputState;\n      if (!state) {\n        const routes = order.map((routeName: string) => {\n          const tabRouter = tabRouters[routeName];\n          if (tabRouter) {\n            const childAction =\n              action.action ||\n              NavigationActions.init({\n                ...(action.params ? { params: action.params } : {}),\n              });\n            return {\n              ...tabRouter.getStateForAction(childAction),\n              key: routeName,\n              routeName,\n            };\n          }\n          return {\n            key: routeName,\n            routeName,\n          };\n        });\n        state = {\n          routes,\n          index: initialRouteIndex,\n        };\n        // console.log(`${order.join('-')}: Initial state`, {state});\n      }\n\n      if (action.type === NavigationActions.INIT) {\n        // Merge any params from the action into all the child routes\n        const { params } = action;\n        if (params) {\n          state.routes = state.routes.map(\n            (route: *) =>\n              ({\n                ...route,\n                params: {\n                  ...route.params,\n                  ...params,\n                },\n              }: NavigationRoute)\n          );\n        }\n      }\n\n      // Let the current tab handle it\n      const activeTabLastState = state.routes[state.index];\n      const activeTabRouter = tabRouters[order[state.index]];\n      if (activeTabRouter) {\n        const activeTabState = activeTabRouter.getStateForAction(\n          action.action || action,\n          activeTabLastState\n        );\n        if (!activeTabState && inputState) {\n          return null;\n        }\n        if (activeTabState && activeTabState !== activeTabLastState) {\n          const routes = [...state.routes];\n          routes[state.index] = activeTabState;\n          return {\n            ...state,\n            routes,\n          };\n        }\n      }\n\n      // Handle tab changing. Do this after letting the current tab try to\n      // handle the action, to allow inner tabs to change first\n      let activeTabIndex = state.index;\n      const isBackEligible =\n        action.key == null || action.key === activeTabLastState.key;\n      if (\n        action.type === NavigationActions.BACK &&\n        isBackEligible &&\n        shouldBackNavigateToInitialRoute\n      ) {\n        activeTabIndex = initialRouteIndex;\n      }\n      let didNavigate = false;\n      if (action.type === NavigationActions.NAVIGATE) {\n        const navigateAction = ((action: *): NavigationNavigateAction);\n        didNavigate = !!order.find((tabId: string, i: number) => {\n          if (tabId === navigateAction.routeName) {\n            activeTabIndex = i;\n            return true;\n          }\n          return false;\n        });\n        if (didNavigate) {\n          const childState = state.routes[activeTabIndex];\n          let newChildState;\n\n          const tabRouter = tabRouters[action.routeName];\n\n          if (action.action) {\n            newChildState = tabRouter\n              ? tabRouter.getStateForAction(action.action, childState)\n              : null;\n          } else if (!tabRouter && action.params) {\n            newChildState = {\n              ...childState,\n              params: {\n                ...(childState.params || {}),\n                ...action.params,\n              },\n            };\n          }\n\n          if (newChildState && newChildState !== childState) {\n            const routes = [...state.routes];\n            routes[activeTabIndex] = newChildState;\n            return {\n              ...state,\n              routes,\n              index: activeTabIndex,\n            };\n          }\n        }\n      }\n      if (action.type === NavigationActions.SET_PARAMS) {\n        const key = action.key;\n        const lastRoute = state.routes.find(\n          (route: NavigationRoute) => route.key === key\n        );\n        if (lastRoute) {\n          const params = {\n            ...lastRoute.params,\n            ...action.params,\n          };\n          const routes = [...state.routes];\n          routes[state.routes.indexOf(lastRoute)] = ({\n            ...lastRoute,\n            params,\n          }: NavigationRoute);\n          return {\n            ...state,\n            routes,\n          };\n        }\n      }\n      if (activeTabIndex !== state.index) {\n        return {\n          ...state,\n          index: activeTabIndex,\n        };\n      } else if (didNavigate && !inputState) {\n        return state;\n      } else if (didNavigate) {\n        return null;\n      }\n\n      // Let other tabs handle it and switch to the first tab that returns a new state\n      let index = state.index;\n      /* $FlowFixMe */\n      let routes: Array<NavigationState> = state.routes;\n      order.find((tabId: string, i: number) => {\n        const tabRouter = tabRouters[tabId];\n        if (i === index) {\n          return false;\n        }\n        let tabState = routes[i];\n        if (tabRouter) {\n          // console.log(`${order.join('-')}: Processing child router:`, {action, tabState});\n          tabState = tabRouter.getStateForAction(action, tabState);\n        }\n        if (!tabState) {\n          index = i;\n          return true;\n        }\n        if (tabState !== routes[i]) {\n          routes = [...routes];\n          routes[i] = tabState;\n          index = i;\n          return true;\n        }\n        return false;\n      });\n      // console.log(`${order.join('-')}: Processed other tabs:`, {lastIndex: state.index, index});\n\n      // keep active tab index if action type is SET_PARAMS\n      index =\n        action.type === NavigationActions.SET_PARAMS ? state.index : index;\n\n      if (index !== state.index || routes !== state.routes) {\n        return {\n          ...state,\n          index,\n          routes,\n        };\n      }\n      return state;\n    },\n\n    getComponentForState(state: NavigationState): NavigationComponent {\n      const routeName = order[state.index];\n      invariant(\n        routeName,\n        `There is no route defined for index ${state.index}. Check that\n        that you passed in a navigation state with a valid tab/screen index.`\n      );\n      const childRouter = tabRouters[routeName];\n      if (childRouter) {\n        return childRouter.getComponentForState(state.routes[state.index]);\n      }\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n\n    getComponentForRouteName(routeName: string): NavigationComponent {\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n\n    getPathAndParamsForState(state: NavigationState) {\n      const route = state.routes[state.index];\n      const routeName = order[state.index];\n      const subPath = paths[routeName];\n      const screen = getScreenForRouteName(routeConfigs, routeName);\n      let path = subPath;\n      let params = route.params;\n      if (screen && screen.router) {\n        // $FlowFixMe there's no way type the specific shape of the nav state\n        const stateRoute: NavigationStateRoute = route;\n        // If it has a router it's a navigator.\n        // If it doesn't have router it's an ordinary React component.\n        const child = screen.router.getPathAndParamsForState(stateRoute);\n        path = subPath ? `${subPath}/${child.path}` : child.path;\n        params = child.params ? { ...params, ...child.params } : params;\n      }\n      return {\n        path,\n        params,\n      };\n    },\n\n    /**\n     * Gets an optional action, based on a relative path and query params.\n     *\n     * This will return null if there is no action matched\n     */\n    getActionForPathAndParams(\n      path: string,\n      params: ?NavigationParams\n    ): ?NavigationTabAction {\n      return (\n        order\n          .map((tabId: string) => {\n            const parts = path.split('/');\n            const pathToTest = paths[tabId];\n            if (parts[0] === pathToTest) {\n              const tabRouter = tabRouters[tabId];\n              const action: NavigationNavigateAction = NavigationActions.navigate(\n                {\n                  routeName: tabId,\n                }\n              );\n              if (tabRouter && tabRouter.getActionForPathAndParams) {\n                action.action = tabRouter.getActionForPathAndParams(\n                  parts.slice(1).join('/'),\n                  params\n                );\n              } else if (params) {\n                action.params = params;\n              }\n              return action;\n            }\n            return null;\n          })\n          .find((action: *) => !!action) ||\n        order\n          .map((tabId: string) => {\n            const tabRouter = tabRouters[tabId];\n            return (\n              tabRouter && tabRouter.getActionForPathAndParams(path, params)\n            );\n          })\n          .find((action: *) => !!action) ||\n        null\n      );\n    },\n\n    getScreenOptions: createConfigGetter(\n      routeConfigs,\n      config.navigationOptions\n    ),\n\n    getScreenConfig: getScreenConfigDeprecated,\n  };\n};\n"]}]