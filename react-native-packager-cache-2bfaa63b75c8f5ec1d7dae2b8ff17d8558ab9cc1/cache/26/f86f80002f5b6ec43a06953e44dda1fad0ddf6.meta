["60666d0a4c70cb997f2e7f3cdec17eec0d77aa40","6adddcdac49c193feaf82ffa5db183c5df35f7a4",["./util/Path","./snap/indexes/PriorityIndex","./util/CountedSet"],[99,145,205],{"version":3,"sources":["/home/giise/candidtwo/node_modules/@firebase/database/dist/cjs/src/core/SparseSnapshotTree.js"],"names":["Object","defineProperty","exports","value","Path_1","require","PriorityIndex_1","CountedSet_1","SparseSnapshotTree","value_","children_","prototype","find","path","getChild","isEmpty","childKey","getFront","popFront","contains","childTree","get","remember","data","updateChild","CountedSet","add","child","forget","isLeafNode","self_1","forEachChild","PRIORITY_INDEX","key","tree","Path","safeToRemove","remove","forEachTree","prefixPath","func","toString","each"],"mappings":"AAAA;;AAgBAA,OAAOC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C,EAAEC,OAAO,IAAT,EAA7C;AACA,IAAIC,SAASC,QAAQ,aAAR,CAAb;AACA,IAAIC,kBAAkBD,QAAQ,8BAAR,CAAtB;AACA,IAAIE,eAAeF,QAAQ,mBAAR,CAAnB;;AAMA,IAAIG,qBAAoC,YAAY;AAChD,aAASA,kBAAT,GAA8B;AAK1B,aAAKC,MAAL,GAAc,IAAd;;AAKA,aAAKC,SAAL,GAAiB,IAAjB;AACH;;AAODF,uBAAmBG,SAAnB,CAA6BC,IAA7B,GAAoC,UAAUC,IAAV,EAAgB;AAChD,YAAI,KAAKJ,MAAL,IAAe,IAAnB,EAAyB;AACrB,mBAAO,KAAKA,MAAL,CAAYK,QAAZ,CAAqBD,IAArB,CAAP;AACH,SAFD,MAGK,IAAI,CAACA,KAAKE,OAAL,EAAD,IAAmB,KAAKL,SAAL,IAAkB,IAAzC,EAA+C;AAChD,gBAAIM,WAAWH,KAAKI,QAAL,EAAf;AACAJ,mBAAOA,KAAKK,QAAL,EAAP;AACA,gBAAI,KAAKR,SAAL,CAAeS,QAAf,CAAwBH,QAAxB,CAAJ,EAAuC;AACnC,oBAAII,YAAY,KAAKV,SAAL,CAAeW,GAAf,CAAmBL,QAAnB,CAAhB;AACA,uBAAOI,UAAUR,IAAV,CAAeC,IAAf,CAAP;AACH,aAHD,MAIK;AACD,uBAAO,IAAP;AACH;AACJ,SAVI,MAWA;AACD,mBAAO,IAAP;AACH;AACJ,KAlBD;;AA0BAL,uBAAmBG,SAAnB,CAA6BW,QAA7B,GAAwC,UAAUT,IAAV,EAAgBU,IAAhB,EAAsB;AAC1D,YAAIV,KAAKE,OAAL,EAAJ,EAAoB;AAChB,iBAAKN,MAAL,GAAcc,IAAd;AACA,iBAAKb,SAAL,GAAiB,IAAjB;AACH,SAHD,MAIK,IAAI,KAAKD,MAAL,KAAgB,IAApB,EAA0B;AAC3B,iBAAKA,MAAL,GAAc,KAAKA,MAAL,CAAYe,WAAZ,CAAwBX,IAAxB,EAA8BU,IAA9B,CAAd;AACH,SAFI,MAGA;AACD,gBAAI,KAAKb,SAAL,IAAkB,IAAtB,EAA4B;AACxB,qBAAKA,SAAL,GAAiB,IAAIH,aAAakB,UAAjB,EAAjB;AACH;AACD,gBAAIT,WAAWH,KAAKI,QAAL,EAAf;AACA,gBAAI,CAAC,KAAKP,SAAL,CAAeS,QAAf,CAAwBH,QAAxB,CAAL,EAAwC;AACpC,qBAAKN,SAAL,CAAegB,GAAf,CAAmBV,QAAnB,EAA6B,IAAIR,kBAAJ,EAA7B;AACH;AACD,gBAAImB,QAAQ,KAAKjB,SAAL,CAAeW,GAAf,CAAmBL,QAAnB,CAAZ;AACAH,mBAAOA,KAAKK,QAAL,EAAP;AACAS,kBAAML,QAAN,CAAeT,IAAf,EAAqBU,IAArB;AACH;AACJ,KApBD;;AA2BAf,uBAAmBG,SAAnB,CAA6BiB,MAA7B,GAAsC,UAAUf,IAAV,EAAgB;AAClD,YAAIA,KAAKE,OAAL,EAAJ,EAAoB;AAChB,iBAAKN,MAAL,GAAc,IAAd;AACA,iBAAKC,SAAL,GAAiB,IAAjB;AACA,mBAAO,IAAP;AACH,SAJD,MAKK;AACD,gBAAI,KAAKD,MAAL,KAAgB,IAApB,EAA0B;AACtB,oBAAI,KAAKA,MAAL,CAAYoB,UAAZ,EAAJ,EAA8B;AAE1B,2BAAO,KAAP;AACH,iBAHD,MAIK;AACD,wBAAI1B,QAAQ,KAAKM,MAAjB;AACA,yBAAKA,MAAL,GAAc,IAAd;AACA,wBAAIqB,SAAS,IAAb;AACA3B,0BAAM4B,YAAN,CAAmBzB,gBAAgB0B,cAAnC,EAAmD,UAAUC,GAAV,EAAeC,IAAf,EAAqB;AACpEJ,+BAAOR,QAAP,CAAgB,IAAIlB,OAAO+B,IAAX,CAAgBF,GAAhB,CAAhB,EAAsCC,IAAtC;AACH,qBAFD;AAGA,2BAAO,KAAKN,MAAL,CAAYf,IAAZ,CAAP;AACH;AACJ,aAdD,MAeK,IAAI,KAAKH,SAAL,KAAmB,IAAvB,EAA6B;AAC9B,oBAAIM,WAAWH,KAAKI,QAAL,EAAf;AACAJ,uBAAOA,KAAKK,QAAL,EAAP;AACA,oBAAI,KAAKR,SAAL,CAAeS,QAAf,CAAwBH,QAAxB,CAAJ,EAAuC;AACnC,wBAAIoB,eAAe,KAAK1B,SAAL,CAAeW,GAAf,CAAmBL,QAAnB,EAA6BY,MAA7B,CAAoCf,IAApC,CAAnB;AACA,wBAAIuB,YAAJ,EAAkB;AACd,6BAAK1B,SAAL,CAAe2B,MAAf,CAAsBrB,QAAtB;AACH;AACJ;AACD,oBAAI,KAAKN,SAAL,CAAeK,OAAf,EAAJ,EAA8B;AAC1B,yBAAKL,SAAL,GAAiB,IAAjB;AACA,2BAAO,IAAP;AACH,iBAHD,MAIK;AACD,2BAAO,KAAP;AACH;AACJ,aAhBI,MAiBA;AACD,uBAAO,IAAP;AACH;AACJ;AACJ,KA3CD;;AAmDAF,uBAAmBG,SAAnB,CAA6B2B,WAA7B,GAA2C,UAAUC,UAAV,EAAsBC,IAAtB,EAA4B;AACnE,YAAI,KAAK/B,MAAL,KAAgB,IAApB,EAA0B;AACtB+B,iBAAKD,UAAL,EAAiB,KAAK9B,MAAtB;AACH,SAFD,MAGK;AACD,iBAAKsB,YAAL,CAAkB,UAAUE,GAAV,EAAeC,IAAf,EAAqB;AACnC,oBAAIrB,OAAO,IAAIT,OAAO+B,IAAX,CAAgBI,WAAWE,QAAX,KAAwB,GAAxB,GAA8BR,GAA9C,CAAX;AACAC,qBAAKI,WAAL,CAAiBzB,IAAjB,EAAuB2B,IAAvB;AACH,aAHD;AAIH;AACJ,KAVD;;AAgBAhC,uBAAmBG,SAAnB,CAA6BoB,YAA7B,GAA4C,UAAUS,IAAV,EAAgB;AACxD,YAAI,KAAK9B,SAAL,KAAmB,IAAvB,EAA6B;AACzB,iBAAKA,SAAL,CAAegC,IAAf,CAAoB,UAAUT,GAAV,EAAeC,IAAf,EAAqB;AACrCM,qBAAKP,GAAL,EAAUC,IAAV;AACH,aAFD;AAGH;AACJ,KAND;AAOA,WAAO1B,kBAAP;AACH,CAnJuC,EAAxC;AAoJAN,QAAQM,kBAAR,GAA6BA,kBAA7B","sourcesContent":["\"use strict\";\n/**\n * Copyright 2017 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Path_1 = require(\"./util/Path\");\nvar PriorityIndex_1 = require(\"./snap/indexes/PriorityIndex\");\nvar CountedSet_1 = require(\"./util/CountedSet\");\n/**\n * Helper class to store a sparse set of snapshots.\n *\n * @constructor\n */\nvar SparseSnapshotTree = /** @class */ (function () {\n    function SparseSnapshotTree() {\n        /**\n         * @private\n         * @type {Node}\n         */\n        this.value_ = null;\n        /**\n         * @private\n         * @type {CountedSet}\n         */\n        this.children_ = null;\n    }\n    /**\n     * Gets the node stored at the given path if one exists.\n     *\n     * @param {!Path} path Path to look up snapshot for.\n     * @return {?Node} The retrieved node, or null.\n     */\n    SparseSnapshotTree.prototype.find = function (path) {\n        if (this.value_ != null) {\n            return this.value_.getChild(path);\n        }\n        else if (!path.isEmpty() && this.children_ != null) {\n            var childKey = path.getFront();\n            path = path.popFront();\n            if (this.children_.contains(childKey)) {\n                var childTree = this.children_.get(childKey);\n                return childTree.find(path);\n            }\n            else {\n                return null;\n            }\n        }\n        else {\n            return null;\n        }\n    };\n    /**\n     * Stores the given node at the specified path. If there is already a node\n     * at a shallower path, it merges the new data into that snapshot node.\n     *\n     * @param {!Path} path Path to look up snapshot for.\n     * @param {!Node} data The new data, or null.\n     */\n    SparseSnapshotTree.prototype.remember = function (path, data) {\n        if (path.isEmpty()) {\n            this.value_ = data;\n            this.children_ = null;\n        }\n        else if (this.value_ !== null) {\n            this.value_ = this.value_.updateChild(path, data);\n        }\n        else {\n            if (this.children_ == null) {\n                this.children_ = new CountedSet_1.CountedSet();\n            }\n            var childKey = path.getFront();\n            if (!this.children_.contains(childKey)) {\n                this.children_.add(childKey, new SparseSnapshotTree());\n            }\n            var child = this.children_.get(childKey);\n            path = path.popFront();\n            child.remember(path, data);\n        }\n    };\n    /**\n     * Purge the data at path from the cache.\n     *\n     * @param {!Path} path Path to look up snapshot for.\n     * @return {boolean} True if this node should now be removed.\n     */\n    SparseSnapshotTree.prototype.forget = function (path) {\n        if (path.isEmpty()) {\n            this.value_ = null;\n            this.children_ = null;\n            return true;\n        }\n        else {\n            if (this.value_ !== null) {\n                if (this.value_.isLeafNode()) {\n                    // We're trying to forget a node that doesn't exist\n                    return false;\n                }\n                else {\n                    var value = this.value_;\n                    this.value_ = null;\n                    var self_1 = this;\n                    value.forEachChild(PriorityIndex_1.PRIORITY_INDEX, function (key, tree) {\n                        self_1.remember(new Path_1.Path(key), tree);\n                    });\n                    return this.forget(path);\n                }\n            }\n            else if (this.children_ !== null) {\n                var childKey = path.getFront();\n                path = path.popFront();\n                if (this.children_.contains(childKey)) {\n                    var safeToRemove = this.children_.get(childKey).forget(path);\n                    if (safeToRemove) {\n                        this.children_.remove(childKey);\n                    }\n                }\n                if (this.children_.isEmpty()) {\n                    this.children_ = null;\n                    return true;\n                }\n                else {\n                    return false;\n                }\n            }\n            else {\n                return true;\n            }\n        }\n    };\n    /**\n     * Recursively iterates through all of the stored tree and calls the\n     * callback on each one.\n     *\n     * @param {!Path} prefixPath Path to look up node for.\n     * @param {!Function} func The function to invoke for each tree.\n     */\n    SparseSnapshotTree.prototype.forEachTree = function (prefixPath, func) {\n        if (this.value_ !== null) {\n            func(prefixPath, this.value_);\n        }\n        else {\n            this.forEachChild(function (key, tree) {\n                var path = new Path_1.Path(prefixPath.toString() + '/' + key);\n                tree.forEachTree(path, func);\n            });\n        }\n    };\n    /**\n     * Iterates through each immediate child and triggers the callback.\n     *\n     * @param {!Function} func The function to invoke for each child.\n     */\n    SparseSnapshotTree.prototype.forEachChild = function (func) {\n        if (this.children_ !== null) {\n            this.children_.each(function (key, tree) {\n                func(key, tree);\n            });\n        }\n    };\n    return SparseSnapshotTree;\n}());\nexports.SparseSnapshotTree = SparseSnapshotTree;\n\n//# sourceMappingURL=SparseSnapshotTree.js.map\n"]}]